

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyfasst.audioModel &mdash; pyFASST 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyFASST 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyFASST 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyfasst.audioModel</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;AudioModel: </span>

<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">FASST (Flexible Audio Source Separation Toolbox) class</span>
<span class="sd">    subclass it to obtain your own flavoured source separation model!</span>

<span class="sd">Usage</span>
<span class="sd">-----</span>

<span class="sd">TBD</span>

<span class="sd">Reference</span>
<span class="sd">---------</span>

<span class="sd">    A. Ozerov, E. Vincent and F. Bimbot</span>
<span class="sd">    \&quot;A General Flexible Framework for the Handling of Prior Information</span>
<span class="sd">    in Audio Source Separation,\&quot; </span>
<span class="sd">    IEEE Transactions on Audio, Speech and Signal Processing 20(4),</span>
<span class="sd">    pp. 1118-1133 (2012)                            </span>
<span class="sd">    Available: `Archive on HAL &lt;http://hal.inria.fr/hal-00626962/&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    Adapted from the Matlab toolbox available at</span>
<span class="sd">    http://bass-db.gforge.inria.fr/fasst/</span>

<span class="sd">Copyright (TBD)</span>
<span class="sd">---------------</span>

<span class="sd">Jean-Louis Durrieu, EPFL-SSTI-IEL-LTS5</span>
<span class="sd">::</span>

<span class="sd">    jean DASH louis AT durrieu DOT ch</span>

<span class="sd">2012-2013</span>

<span class="sd">Reference</span>
<span class="sd">---------</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">audioObject</span> <span class="kn">as</span> <span class="nn">ao</span>
<span class="kn">import</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">tools.signalTools</span> <span class="kn">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">SeparateLeadStereo</span> <span class="kn">import</span> <span class="n">SeparateLeadStereoTF</span> <span class="k">as</span> <span class="n">SLS</span>
<span class="kn">import</span> <span class="nn">demixTF</span> <span class="kn">as</span> <span class="nn">demix</span>
<span class="kn">import</span> <span class="nn">tftransforms.tft</span> <span class="kn">as</span> <span class="nn">tft</span> <span class="c"># loads the possible transforms</span>

<span class="n">tftransforms</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;stftold&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">TFTransform</span><span class="p">,</span> <span class="c"># just making dummy, in FASST, not used</span>
    <span class="s">&#39;stft&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">STFT</span><span class="p">,</span>
    <span class="s">&#39;mqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">MinQTransfo</span><span class="p">,</span>
    <span class="s">&#39;minqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">MinQTransfo</span><span class="p">,</span>
    <span class="s">&#39;nsgmqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">NSGMinQT</span><span class="p">,</span>
    <span class="s">&#39;cqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">CQTransfo</span><span class="p">}</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="n">log_prior_small_cst</span> <span class="o">=</span> <span class="mf">1e-70</span>
<span class="n">soundCelerity</span> <span class="o">=</span> <span class="mf">340.</span> <span class="c"># m/s</span>

<span class="c">########## Useful functions ##########</span>

<div class="viewcode-block" id="NMF_decomposition"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.NMF_decomposition">[docs]</a><span class="k">def</span> <span class="nf">NMF_decomposition</span><span class="p">(</span><span class="n">SX</span><span class="p">,</span> <span class="n">nbComps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;NMF multiplicative gradient, for Itakura Saito</span>
<span class="sd">    divergence measure between SX and `np.dot(W,H)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">nframes</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nbComps</span><span class="p">,</span> <span class="n">nframes</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">W</span> <span class="o">/=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF iteration </span><span class="si">%d</span><span class="s"> out of </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>
        <span class="c"># updating W</span>
        <span class="n">hatSX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                     <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                     <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="n">W</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        
        <span class="n">sumW</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sumW</span><span class="p">[</span><span class="n">sumW</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">sumW</span>
        <span class="n">H</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sumW</span><span class="p">)</span>
        
        <span class="c"># updating H</span>
        <span class="n">hatSX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                     <span class="n">SX</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                     <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
        
        <span class="n">H</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span>
</div>
<div class="viewcode-block" id="NMF_decomp_init"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.NMF_decomp_init">[docs]</a><span class="k">def</span> <span class="nf">NMF_decomp_init</span><span class="p">(</span><span class="n">SX</span><span class="p">,</span> <span class="n">nbComps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">Winit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Hinit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">updateW</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">updateH</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;NMF multiplicative gradient, for Itakura Saito</span>
<span class="sd">    divergence measure between SX and np.dot(W,H)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">nframes</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">Winit</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Winit</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">)):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">updateW</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: not updating randomly initialized W...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Winit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateW</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial W...&quot;</span> 
            
    <span class="k">if</span> <span class="n">Hinit</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nbComps</span><span class="p">,</span> <span class="n">nframes</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Hinit</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateH</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial H...&quot;</span>
    <span class="k">elif</span>  <span class="n">Hinit</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Hinit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateH</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial H...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">,</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">updateH</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: not updating randomly initialized H...&quot;</span>
    
    <span class="k">if</span> <span class="n">updateW</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF iteration </span><span class="si">%d</span><span class="s"> out of </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">updateW</span><span class="p">:</span><span class="c"># updating W</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">H</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">H</span><span class="p">)</span>
            
            <span class="n">W</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            
            <span class="n">sumW</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sumW</span><span class="p">[</span><span class="n">sumW</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">W</span> <span class="o">/=</span> <span class="n">sumW</span>
            <span class="n">H</span> <span class="o">*=</span> <span class="n">sumW</span>
        
        <span class="k">if</span> <span class="n">updateH</span><span class="p">:</span><span class="c"># updating H</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">W</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">W</span><span class="p">)</span>
            
            <span class="n">H</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span>
</div>
<div class="viewcode-block" id="SFNMF_decomp_init"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.SFNMF_decomp_init">[docs]</a><span class="k">def</span> <span class="nf">SFNMF_decomp_init</span><span class="p">(</span><span class="n">SX</span><span class="p">,</span> <span class="n">nbComps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nbFiltComps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                      <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">Winit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Hinit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">WFiltInit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HFiltInit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">updateW</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">updateH</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                      <span class="n">updateWFilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">updateHFilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                      <span class="n">nbResComps</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements a simple source/filter NMF algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">nframes</span> <span class="o">=</span> <span class="n">SX</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">Winit</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Winit</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">)):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">updateW</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: not updating randomly initialized W...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Winit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateW</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial W...&quot;</span> 
    <span class="k">if</span> <span class="n">Hinit</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Hinit</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">)):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbComps</span><span class="p">,</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">updateH</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: not updating randomly initialized H...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Hinit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateH</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial H...&quot;</span>
    
    <span class="k">if</span> <span class="n">updateW</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">/=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">WFiltInit</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">WFiltInit</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbFiltComps</span><span class="p">)):</span>
        <span class="n">WFilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbFiltComps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">updateWFilt</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: not &quot;</span><span class="o">+</span>\
                  <span class="s">&quot;updating randomly initialized WFilt...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">WFilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">WFiltInit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateWFilt</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial WFilt...&quot;</span> 
    <span class="k">if</span> <span class="n">HFiltInit</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">HFiltInit</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbFiltComps</span><span class="p">)):</span>
        <span class="n">HFilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbFiltComps</span><span class="p">,</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">updateHFilt</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: not updating &quot;</span><span class="o">+</span>\
                  <span class="s">&quot;randomly initialized HFilt...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">HFilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">HFiltInit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">updateHFilt</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF decomp init: updating provided initial H...&quot;</span>
    
    <span class="k">if</span> <span class="n">updateWFilt</span><span class="p">:</span>
        <span class="n">WFilt</span> <span class="o">/=</span> <span class="n">WFilt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">Wres</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">nbResComps</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Hres</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nframes</span><span class="p">,</span> <span class="n">nbResComps</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">SX</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">SX</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    NMF iteration </span><span class="si">%d</span><span class="s"> out of </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">niter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">updateW</span><span class="p">:</span><span class="c"># updating W</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;        updating w f0&quot;</span>
            <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WFilt</span><span class="p">,</span> <span class="n">HFilt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">Sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wres</span><span class="p">,</span> <span class="n">Hres</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">Sres</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span> <span class="o">*</span> <span class="n">SPHI</span><span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">H</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SPHI</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">H</span><span class="p">)</span>
            
            <span class="n">W</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            
            <span class="n">sumW</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sumW</span><span class="p">[</span><span class="n">sumW</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">W</span> <span class="o">/=</span> <span class="n">sumW</span>
            <span class="n">H</span> <span class="o">*=</span> <span class="n">sumW</span>
        
        <span class="k">if</span> <span class="n">updateH</span><span class="p">:</span><span class="c"># updating H</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;        updating h f0&quot;</span>
            <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">HFilt</span><span class="p">,</span> <span class="n">WFilt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">Sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Hres</span><span class="p">,</span> <span class="n">Wres</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">Sres</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">SPHI</span><span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">W</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SPHI</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">W</span><span class="p">)</span>
            
            <span class="n">H</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hatSX</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="n">im</span><span class="o">.</span><span class="n">set_clim</span><span class="p">([</span><span class="n">im</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                             <span class="n">im</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            
        <span class="k">if</span> <span class="n">updateWFilt</span><span class="p">:</span><span class="c"># updating WFilt</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;        updating w filter&quot;</span>
            <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WFilt</span><span class="p">,</span> <span class="n">HFilt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">Sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wres</span><span class="p">,</span> <span class="n">Hres</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">Sres</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">HFilt</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SF0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">HFilt</span><span class="p">)</span>
            
            <span class="n">WFilt</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            
            <span class="c"># normalization of Wfilt</span>
            <span class="n">sumW</span> <span class="o">=</span> <span class="n">WFilt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sumW</span><span class="p">[</span><span class="n">sumW</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">WFilt</span> <span class="o">/=</span> <span class="n">sumW</span>
            <span class="n">HFilt</span> <span class="o">*=</span> <span class="n">sumW</span>
            <span class="c"># normalizing Hfilt and sending energy to H</span>
            <span class="c">##sumH = HFilt.sum(axis=1)</span>
            <span class="c">##HFilt /= np.vstack(sumH)</span>
            <span class="c">##H *= np.vstack(sumH)</span>
        
        <span class="k">if</span> <span class="n">updateHFilt</span><span class="p">:</span><span class="c"># updating HFilt</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;        updating h filter&quot;</span>
            <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">HFilt</span><span class="p">,</span> <span class="n">WFilt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">Sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Hres</span><span class="p">,</span> <span class="n">Wres</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">Sres</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">im2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hatSX</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="n">im2</span><span class="o">.</span><span class="n">set_clim</span><span class="p">([</span><span class="n">im2</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                              <span class="n">im2</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">WFilt</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SF0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                         <span class="n">WFilt</span><span class="p">)</span>
            
            <span class="n">HFilt</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            
            <span class="c"># normalizing Hfilt and sending energy to H</span>
            <span class="n">sumH</span> <span class="o">=</span> <span class="n">HFilt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">H</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sumH</span><span class="p">)</span>
            <span class="n">sumH</span><span class="p">[</span><span class="n">sumH</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">HFilt</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sumH</span><span class="p">)</span>
            
            <span class="c">##if verbose&gt;1:</span>
            <span class="c">##    im2.set_data(np.log(HFilt.T))</span>
            <span class="c">##    im2.set_clim([im2.get_array().min(),</span>
            <span class="c">##                  im2.get_array().max()])</span>
            <span class="c">##    plt.draw()</span>
        <span class="c"># update residual comps:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;        updating w residual&quot;</span>
        <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WFilt</span><span class="p">,</span> <span class="n">HFilt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wres</span><span class="p">,</span> <span class="n">Hres</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">hatSX</span> <span class="o">=</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">Sres</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                     <span class="n">Hres</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                     <span class="n">Hres</span><span class="p">)</span>
        
        <span class="n">Wres</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        
        <span class="c"># normalization of Wfilt</span>
        <span class="n">sumW</span> <span class="o">=</span> <span class="n">Wres</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sumW</span><span class="p">[</span><span class="n">sumW</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">Wres</span> <span class="o">/=</span> <span class="n">sumW</span>
        <span class="n">Hres</span> <span class="o">*=</span> <span class="n">sumW</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;        updating h residual&quot;</span>
        <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">HFilt</span><span class="p">,</span> <span class="n">WFilt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Sres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Hres</span><span class="p">,</span> <span class="n">Wres</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">hatSX</span> <span class="o">=</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">Sres</span>
            
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SX</span><span class="o">.</span><span class="n">T</span>  <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                     <span class="n">Wres</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSX</span><span class="p">,</span> <span class="n">eps</span><span class="p">),</span>
                     <span class="n">Wres</span><span class="p">)</span>
        
        <span class="n">Hres</span> <span class="o">*=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">WFilt</span><span class="p">,</span> <span class="n">HFilt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Wres</span><span class="p">,</span> <span class="n">Hres</span>
    
</div>
<div class="viewcode-block" id="inv_mat"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.inv_mat">[docs]</a><span class="k">def</span> <span class="nf">inv_mat</span><span class="p">(</span><span class="n">mat_diag</span><span class="p">,</span> <span class="n">mat_off</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;invert hermitian matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">det_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mat_diag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mat_off</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">det_mat</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">det_mat</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">det_mat</span><span class="p">),</span> <span class="n">eps</span><span class="p">)</span>
        <span class="p">)</span>
    
    <span class="n">inv_mat_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mat_diag</span><span class="p">)</span>
    <span class="n">inv_mat_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">det_mat</span>
    <span class="n">inv_mat_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">det_mat</span>
    <span class="n">inv_mat_off</span> <span class="o">=</span> <span class="o">-</span> <span class="n">mat_off</span> <span class="o">/</span> <span class="n">det_mat</span>
    
    <span class="k">return</span> <span class="n">inv_mat_diag</span><span class="p">,</span> <span class="n">inv_mat_off</span><span class="p">,</span> <span class="n">det_mat</span>
</div>
<div class="viewcode-block" id="gen_steer_vec_far_src_uniform_linear_array"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.gen_steer_vec_far_src_uniform_linear_array">[docs]</a><span class="k">def</span> <span class="nf">gen_steer_vec_far_src_uniform_linear_array</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span>
                                               <span class="n">nchannels</span><span class="p">,</span>
                                               <span class="n">theta</span><span class="p">,</span>
                                               <span class="n">distanceInterMic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;generate steering vector with relative far source,</span>
<span class="sd">    uniformly spaced sensor array</span>
<span class="sd">    </span>
<span class="sd">    **Description**:</span>
<span class="sd">    </span>
<span class="sd">    assuming the source is far (compared to the dimensions of the array)</span>
<span class="sd">    The sensor array is also assumed to be a linear array, the direction of</span>
<span class="sd">    arrival (DOA) theta is defined as in the following incredible ASCII</span>
<span class="sd">    art drawing::</span>
<span class="sd">    </span>
<span class="sd">          theta</span>
<span class="sd">        -----&gt;/              /</span>
<span class="sd">        |    /              /</span>
<span class="sd">        y   /              /</span>
<span class="sd">           /              /</span>
<span class="sd">        ^ /              /</span>
<span class="sd">        |/              /</span>
<span class="sd">        +---&gt; x</span>
<span class="sd">        o    o    o    o    o    o</span>
<span class="sd">        M1   M2   M3  ...</span>
<span class="sd">        &lt;---&gt;</span>
<span class="sd">          d = distanceInterMic</span>
<span class="sd">    </span>
<span class="sd">    That is more likely valid for electro-magnetic fields, for acoustic</span>
<span class="sd">    wave fields, one should probably take into account the difference of</span>
<span class="sd">    gain between the microphones (see ``gen_steer_vec_acous``)</span>
<span class="sd">    </span>
<span class="sd">    **Output**:</span>
<span class="sd">    </span>
<span class="sd">    a (nc, nfreqs) ndarray</span>
<span class="sd">        contains the steering vectors, one for each channel, and</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span>
               <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nchannels</span><span class="p">),</span>
                        <span class="n">freqs</span><span class="p">)</span> <span class="o">*</span>
               <span class="p">(</span><span class="n">distanceInterMic</span> <span class="o">/</span> <span class="n">soundCelerity</span><span class="p">)</span> <span class="o">*</span> 
               <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span>
</div>
<div class="viewcode-block" id="gen_steer_vec_acous"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.gen_steer_vec_acous">[docs]</a><span class="k">def</span> <span class="nf">gen_steer_vec_acous</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span>
                        <span class="n">dist_src_mic</span><span class="p">):</span>
    <span class="n">gains</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">4.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">dist_src_mic</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span> <span class="o">*</span>
         <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dist_src_mic</span><span class="p">,</span>
                         <span class="n">freqs</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">soundCelerity</span>
                <span class="p">)</span>
         <span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
</div>
<div class="viewcode-block" id="dir_diag_stereo"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.dir_diag_stereo">[docs]</a><span class="k">def</span> <span class="nf">dir_diag_stereo</span><span class="p">(</span><span class="n">Cx</span><span class="p">,</span>
                    <span class="n">nft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
                    <span class="n">ntheta</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                    <span class="n">samplerate</span><span class="o">=</span><span class="mi">44100</span><span class="p">,</span><span class="c">#Hz</span>
                    <span class="n">distanceInterMic</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="c">#m</span>
                    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the diagram of directivity for the input</span>
<span class="sd">    short time Fourier transform second order statistics in Cx</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        C_x[0] = E[|x_0|^2]</span>
<span class="sd">        </span>
<span class="sd">        C_x[2] = E[|x_1|^2]</span>
<span class="sd">        </span>
<span class="sd">        C_x[1] = E[x_0 x_1^H]</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    **Method**:</span>
<span class="sd">    </span>
<span class="sd">    We use the Capon method, on each of the Fourier channel:</span>
<span class="sd">    </span>
<span class="sd">        phi_k(theta) = a_k(theta).H inv(Rxx) a_k(theta)</span>
<span class="sd">    </span>
<span class="sd">    The algorithm therefore returns one directivity graph for each</span>
<span class="sd">    frequency band. </span>
<span class="sd">    </span>
<span class="sd">    **Remarks**:</span>
<span class="sd">    </span>
<span class="sd">    One can compute a summary directivity by adding the directivity functions</span>
<span class="sd">    across all the frequency channels. The invert of the resulting array may</span>
<span class="sd">    also be of interest (looking at peaks and not valleys to find directions):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; directivity_diag = dir_diag_stereo(Cx)</span>
<span class="sd">    &gt;&gt;&gt; summary_dir_diag = 1./directivity_diag.sum(axis=1)</span>
<span class="sd">    </span>
<span class="sd">    Some tests show that it is very important that the distance between the</span>
<span class="sd">    microphone is known. Otherwise, little can be infered from the resulting</span>
<span class="sd">    directivity measure...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nchannels</span> <span class="o">=</span> <span class="mi">2</span> <span class="c"># this function only works for stereo audio</span>
    
    <span class="c"># for capon, we need the average of Cx:</span>
    <span class="n">meanCx_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                            <span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">meanCx_off</span>  <span class="o">=</span> <span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># ... and its inverse:</span>
    <span class="n">inv_mat_diag</span><span class="p">,</span> <span class="n">inv_mat_off</span><span class="p">,</span> <span class="n">det_mat</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">inv_mat</span><span class="p">(</span><span class="n">meanCx_diag</span><span class="p">,</span> <span class="n">meanCx_off</span><span class="p">)</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">det_mat</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s">&quot;Not possible to compute directivity, singular covariance. &quot;</span><span class="o">+</span>
            <span class="s">&quot;</span><span class="se">\n</span><span class="s">The channels are probably either identical or colinear.&quot;</span><span class="p">)</span>
    
    <span class="n">nfreqs</span> <span class="o">=</span> <span class="n">nft</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nfreqs</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">nft</span> <span class="o">*</span> <span class="n">samplerate</span>
    
    <span class="c"># now computing the directivity diagram, angle after angle</span>
    <span class="n">directivity_diagram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ntheta</span><span class="p">,</span> <span class="n">nfreqs</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c"># theta from -pi/2 to +pi/2</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntheta</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">ntheta</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="k">for</span> <span class="n">nth</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntheta</span><span class="p">):</span>
        <span class="c"># Compute steering vectors for each frequency</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">gen_steer_vec_far_src_uniform_linear_array</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span>
                                                          <span class="n">nchannels</span><span class="p">,</span>
                                                          <span class="n">theta</span><span class="p">[</span><span class="n">nth</span><span class="p">],</span>
                                                          <span class="n">distanceInterMic</span><span class="p">)</span>
        
        <span class="n">directivity_diagram</span><span class="p">[</span><span class="n">nth</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">inv_mat_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">inv_mat_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
            <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                         <span class="n">inv_mat_off</span><span class="p">)</span>
            <span class="c">#filt[0] * np.conjugate(filt[1]) * np.conjugate(inv_mat_off) +</span>
            <span class="c">#np.conjugate(filt[0]) * filt[1] * inv_mat_off</span>
            <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">directivity_diagram</span><span class="p">,</span> <span class="n">theta</span>

<span class="c"># coming from sepLeadStereo programs</span>
<span class="c"># (https://github.com/wslihgt/separateLeadStereo):</span></div>
<div class="viewcode-block" id="generate_WF0_chirped"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.generate_WF0_chirped">[docs]</a><span class="k">def</span> <span class="nf">generate_WF0_chirped</span><span class="p">(</span><span class="n">minF0</span><span class="p">,</span> <span class="n">maxF0</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">stepNotes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> \
                         <span class="n">lengthWindow</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">perF0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> \
                         <span class="n">depthChirpInSemiTone</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">loadWF0</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                         <span class="n">analysisWindow</span><span class="o">=</span><span class="s">&#39;hanning&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ``F0Table, WF0 = generate_WF0_chirped(minF0, maxF0, Fs, Nfft=2048,</span>
<span class="sd">    stepNotes=4, lengthWindow=2048,</span>
<span class="sd">    Ot=0.5, perF0=2,</span>
<span class="sd">    depthChirpInSemiTone=0.5)``</span>
<span class="sd">    </span>
<span class="sd">    Generates a &#39;basis&#39; matrix for the source part WF0, using the</span>
<span class="sd">    source model KLGLOTT88, with the following I/O arguments:</span>
<span class="sd">    </span>
<span class="sd">    **Inputs**:</span>
<span class="sd">    </span>
<span class="sd">    *    `minF0`:                the minimum value for the fundamental</span>
<span class="sd">                                 frequency (F0)</span>
<span class="sd">    *    `maxF0`:                the maximum value for F0</span>
<span class="sd">    *    Fs:                     the desired sampling rate</span>
<span class="sd">    *    Nfft:                   the number of bins to compute the Fourier</span>
<span class="sd">                                 transform</span>
<span class="sd">    *    stepNotes:              the number of F0 per semitone</span>
<span class="sd">    *    lengthWindow:           the size of the window for the Fourier</span>
<span class="sd">                                 transform</span>
<span class="sd">    *    Ot:                     the glottal opening coefficient for</span>
<span class="sd">                                 KLGLOTT88</span>
<span class="sd">    *    perF0:                  the number of chirps considered per F0</span>
<span class="sd">                                 value</span>
<span class="sd">    *    depthChirpInSemiTone:   the maximum value, in semitone, of the</span>
<span class="sd">                                 allowed chirp per F0</span>
<span class="sd">                             </span>
<span class="sd">    **Outputs**:</span>
<span class="sd">    </span>
<span class="sd">    *    F0Table:</span>

<span class="sd">                the vector containing the values of the fundamental</span>
<span class="sd">                frequencies in Hertz (Hz) corresponding to the</span>
<span class="sd">                harmonic combs in WF0, i.e. the columns of WF0</span>
<span class="sd">    *    WF0:</span>
<span class="sd">    </span>
<span class="sd">                the basis matrix, where each column is a harmonic comb</span>
<span class="sd">                generated by KLGLOTT88 (with a sinusoidal model, then</span>
<span class="sd">                transformed into the spectral domain)</span>
<span class="sd">                </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># generating a filename to keep data:</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;wf0_&#39;</span><span class="p">,</span>
                             <span class="s">&#39;_minF0-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">minF0</span><span class="p">),</span>
                             <span class="s">&#39;_maxF0-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">maxF0</span><span class="p">),</span>
                             <span class="s">&#39;_Fs-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">Fs</span><span class="p">),</span>
                             <span class="s">&#39;_Nfft-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">Nfft</span><span class="p">),</span>
                             <span class="s">&#39;_stepNotes-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">stepNotes</span><span class="p">),</span>
                             <span class="s">&#39;_Ot-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">Ot</span><span class="p">),</span>
                             <span class="s">&#39;_perF0-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">perF0</span><span class="p">),</span>
                             <span class="s">&#39;_depthChirp-&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">depthChirpInSemiTone</span><span class="p">),</span>
                             <span class="s">&#39;_analysisWindow-&#39;</span><span class="p">,</span> <span class="n">analysisWindow</span><span class="p">,</span>
                             <span class="s">&#39;.npz&#39;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loadWF0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Reading WF0 and F0Table from stored arrays.&quot;</span>
        <span class="n">struc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struc</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">],</span> <span class="n">struc</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span>
    
    <span class="k">print</span> <span class="s">&quot;First time WF0 computed with these parameters, please wait...&quot;</span>
    <span class="c"># converting to double arrays:</span>
    <span class="n">minF0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">minF0</span><span class="p">)</span>
    <span class="n">maxF0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">maxF0</span><span class="p">)</span>
    <span class="n">Fs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">Fs</span><span class="p">)</span>
    <span class="n">stepNotes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">stepNotes</span><span class="p">)</span>
    
    <span class="c"># computing the F0 table:</span>
    <span class="n">numberOfF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="n">stepNotes</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">maxF0</span> <span class="o">/</span> <span class="n">minF0</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">F0Table</span><span class="o">=</span><span class="n">minF0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numberOfF0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span> \
                           <span class="o">/</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">stepNotes</span><span class="p">)))</span>
    
    <span class="n">numberElementsInWF0</span> <span class="o">=</span> <span class="n">numberOfF0</span> <span class="o">*</span> <span class="n">perF0</span>
    
    <span class="c"># computing the desired WF0 matrix</span>
    <span class="n">WF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">numberElementsInWF0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fundamentalFrequency</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numberOfF0</span><span class="p">):</span>
        <span class="n">odgd</span><span class="p">,</span> <span class="n">odgdSpec</span> <span class="o">=</span> \
              <span class="n">generate_ODGD_spec</span><span class="p">(</span><span class="n">F0Table</span><span class="p">[</span><span class="n">fundamentalFrequency</span><span class="p">],</span> <span class="n">Fs</span><span class="p">,</span> \
                                 <span class="n">Ot</span><span class="o">=</span><span class="n">Ot</span><span class="p">,</span> <span class="n">lengthOdgd</span><span class="o">=</span><span class="n">lengthWindow</span><span class="p">,</span> \
                                 <span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>\
                                 <span class="n">analysisWindowType</span><span class="o">=</span><span class="n">analysisWindow</span><span class="p">)</span>
        <span class="n">WF0</span><span class="p">[:,</span><span class="n">fundamentalFrequency</span> <span class="o">*</span> <span class="n">perF0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">odgdSpec</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">chirpNumber</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">perF0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">F2</span> <span class="o">=</span> <span class="n">F0Table</span><span class="p">[</span><span class="n">fundamentalFrequency</span><span class="p">]</span> \
                 <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">((</span><span class="n">chirpNumber</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">depthChirpInSemiTone</span> \
                          <span class="o">/</span> <span class="p">(</span><span class="mf">12.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">perF0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))))</span>
            <span class="c"># F0 is the mean of F1 and F2.</span>
            <span class="n">F1</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">F0Table</span><span class="p">[</span><span class="n">fundamentalFrequency</span><span class="p">]</span> <span class="o">-</span> <span class="n">F2</span> 
            <span class="n">odgd</span><span class="p">,</span> <span class="n">odgdSpec</span> <span class="o">=</span> \
                  <span class="n">generate_ODGD_spec_chirped</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> \
                                             <span class="n">Ot</span><span class="o">=</span><span class="n">Ot</span><span class="p">,</span> \
                                             <span class="n">lengthOdgd</span><span class="o">=</span><span class="n">lengthWindow</span><span class="p">,</span> \
                                             <span class="n">Nfft</span><span class="o">=</span><span class="n">Nfft</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">WF0</span><span class="p">[:,</span><span class="n">fundamentalFrequency</span> <span class="o">*</span> <span class="n">perF0</span> <span class="o">+</span> <span class="n">chirpNumber</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                                       <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">odgdSpec</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    
    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">F0Table</span><span class="o">=</span><span class="n">F0Table</span><span class="p">,</span> <span class="n">WF0</span><span class="o">=</span><span class="n">WF0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">F0Table</span><span class="p">,</span> <span class="n">WF0</span>
</div>
<div class="viewcode-block" id="generate_ODGD_spec"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.generate_ODGD_spec">[docs]</a><span class="k">def</span> <span class="nf">generate_ODGD_spec</span><span class="p">(</span><span class="n">F0</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">lengthOdgd</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> \
                       <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">analysisWindowType</span><span class="o">=</span><span class="s">&#39;sinebell&#39;</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generateODGDspec:</span>
<span class="sd">    </span>
<span class="sd">    generates a waveform ODGD and the corresponding spectrum,</span>
<span class="sd">    using as analysis window the -optional- window given as</span>
<span class="sd">    argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># converting input to double:</span>
    <span class="n">F0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">F0</span><span class="p">)</span>
    <span class="n">Fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">Fs</span><span class="p">)</span>
    <span class="n">Ot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">Ot</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
    
    <span class="c"># compute analysis window of given type:</span>
    <span class="k">if</span> <span class="n">analysisWindowType</span><span class="o">==</span><span class="s">&#39;sinebell&#39;</span><span class="p">:</span>
        <span class="n">analysisWindow</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">analysisWindowType</span><span class="o">==</span><span class="s">&#39;hanning&#39;</span> <span class="ow">or</span> \
               <span class="n">analysisWindowType</span><span class="o">==</span><span class="s">&#39;hanning&#39;</span><span class="p">:</span>
            <span class="n">analysisWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">)</span>
    
    <span class="c"># maximum number of partials in the spectral comb:</span>
    <span class="n">partialMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">Fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">F0</span><span class="p">)</span>
    
    <span class="c"># Frequency numbers of the partials:</span>
    <span class="n">frequency_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">partialMax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c"># intermediate value</span>
    <span class="n">temp_array</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">frequency_numbers</span> <span class="o">*</span> <span class="n">Ot</span>
    
    <span class="c"># compute the amplitudes for each of the frequency peaks:</span>
    <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">F0</span> <span class="o">*</span> <span class="mi">27</span> <span class="o">/</span> <span class="mi">4</span> \
                 <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">temp_array</span><span class="p">)</span> \
                    <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">temp_array</span><span class="p">))</span> <span class="o">/</span> <span class="n">temp_array</span><span class="p">)</span> \
                    <span class="o">-</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">temp_array</span><span class="p">))</span> \
                       <span class="o">/</span> <span class="p">(</span><span class="n">temp_array</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span> \
                       <span class="o">/</span> <span class="n">temp_array</span>
    
    <span class="c"># Time stamps for the time domain ODGD</span>
    <span class="n">timeStamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">)</span> <span class="o">/</span> <span class="n">Fs</span> <span class="o">+</span> <span class="n">t0</span> <span class="o">/</span> <span class="n">F0</span>
    
    <span class="c"># Time domain odgd:</span>
    <span class="n">odgd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">F0</span> <span class="o">*</span> <span class="n">frequency_numbers</span><span class="p">,</span> \
                           <span class="n">timeStamps</span><span class="p">))</span> \
                           <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">))</span>
    <span class="n">odgd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">odgd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c"># spectrum:</span>
    <span class="n">odgdSpectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">odgd</span> <span class="o">*</span> <span class="n">analysisWindow</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">odgd</span><span class="p">,</span> <span class="n">odgdSpectrum</span>
</div>
<div class="viewcode-block" id="generate_ODGD_spec_chirped"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.generate_ODGD_spec_chirped">[docs]</a><span class="k">def</span> <span class="nf">generate_ODGD_spec_chirped</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">lengthOdgd</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> \
                               <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> \
                               <span class="n">analysisWindowType</span><span class="o">=</span><span class="s">&#39;sinebell&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generateODGDspecChirped:</span>
<span class="sd">    </span>
<span class="sd">    generates a waveform ODGD and the corresponding spectrum,</span>
<span class="sd">    using as analysis window the -optional- window given as</span>
<span class="sd">    argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># converting input to double:</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span>
    <span class="n">F2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">F2</span><span class="p">)</span>
    <span class="n">F0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">F1</span> <span class="o">+</span> <span class="n">F2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">Fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">Fs</span><span class="p">)</span>
    <span class="n">Ot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">Ot</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
    
    <span class="c"># compute analysis window of given type:</span>
    <span class="k">if</span> <span class="n">analysisWindowType</span> <span class="o">==</span> <span class="s">&#39;sinebell&#39;</span><span class="p">:</span>
        <span class="n">analysisWindow</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">analysisWindowType</span> <span class="o">==</span> <span class="s">&#39;hanning&#39;</span> <span class="ow">or</span> \
               <span class="n">analysisWindowType</span> <span class="o">==</span> <span class="s">&#39;hann&#39;</span><span class="p">:</span>
            <span class="n">analysisWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">)</span>
    
    <span class="c"># maximum number of partials in the spectral comb:</span>
    <span class="n">partialMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">Fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">))</span>
    
    <span class="c"># Frequency numbers of the partials:</span>
    <span class="n">frequency_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">partialMax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c"># intermediate value</span>
    <span class="n">temp_array</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">frequency_numbers</span> <span class="o">*</span> <span class="n">Ot</span>
    
    <span class="c"># compute the amplitudes for each of the frequency peaks:</span>
    <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">F0</span> <span class="o">*</span> <span class="mi">27</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> \
                 <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">temp_array</span><span class="p">)</span> \
                  <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">temp_array</span><span class="p">))</span> <span class="o">/</span> <span class="n">temp_array</span><span class="p">)</span> \
                  <span class="o">-</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">temp_array</span><span class="p">))</span> \
                     <span class="o">/</span> <span class="p">(</span><span class="n">temp_array</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span> \
                  <span class="o">/</span> <span class="n">temp_array</span>
    
    <span class="c"># Time stamps for the time domain ODGD</span>
    <span class="n">timeStamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">)</span> <span class="o">/</span> <span class="n">Fs</span> <span class="o">+</span> <span class="n">t0</span> <span class="o">/</span> <span class="n">F0</span>
    
    <span class="c"># Time domain odgd:</span>
    <span class="n">odgd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> \
                  <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">F1</span> <span class="o">*</span> <span class="n">frequency_numbers</span><span class="p">,</span><span class="n">timeStamps</span><span class="p">)</span> \
                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">((</span><span class="n">F2</span> <span class="o">-</span> <span class="n">F1</span><span class="p">)</span> \
                                <span class="o">*</span> <span class="n">frequency_numbers</span><span class="p">,</span><span class="n">timeStamps</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> \
                     <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lengthOdgd</span> <span class="o">/</span> <span class="n">Fs</span><span class="p">)))</span> \
                     <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lengthOdgd</span><span class="p">))</span>
    <span class="n">odgd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">odgd</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c"># spectrum:</span>
    <span class="n">odgdSpectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">odgd</span> <span class="o">*</span> <span class="n">analysisWindow</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="n">Nfft</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">odgd</span><span class="p">,</span> <span class="n">odgdSpectrum</span>

<span class="c">########## Filter generation functions   ##########</span>
</div>
<span class="k">def</span> <span class="nf">generateHannBasis</span><span class="p">(</span><span class="n">numberFrequencyBins</span><span class="p">,</span> <span class="n">sizeOfFourier</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> \
                      <span class="n">frequencyScale</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span> <span class="n">numberOfBasis</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> \
                      <span class="n">overlap</span><span class="o">=.</span><span class="mi">75</span><span class="p">):</span>
    <span class="n">isScaleRecognized</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">frequencyScale</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
        <span class="c"># number of windows generated:</span>
        <span class="n">numberOfWindowsForUnit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">))</span>
        <span class="c"># recomputing the overlap to exactly fit the entire</span>
        <span class="c"># number of windows:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">numberOfWindowsForUnit</span><span class="p">)</span>
        <span class="c"># length of the sine window - that is also to say: bandwidth</span>
        <span class="c"># of the sine window:</span>
        <span class="n">lengthSineWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">numberFrequencyBins</span> \
                                   <span class="o">/</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> \
                                      <span class="o">*</span> <span class="p">(</span><span class="n">numberOfBasis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> \
                                      <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">overlap</span><span class="p">))</span>
        <span class="c"># even window length, for convenience:</span>
        <span class="n">lengthSineWindow</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">lengthSineWindow</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> 
        
        <span class="c"># for later compatibility with other frequency scales:</span>
        <span class="n">mappingFrequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numberFrequencyBins</span><span class="p">)</span> 
        
        <span class="c"># size of the &quot;big&quot; window</span>
        <span class="n">sizeBigWindow</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">numberFrequencyBins</span>
        
        <span class="c"># centers for each window</span>
        <span class="c">## the first window is centered at, in number of window:</span>
        <span class="n">firstWindowCenter</span> <span class="o">=</span> <span class="o">-</span> <span class="n">numberOfWindowsForUnit</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c">## and the last is at</span>
        <span class="n">lastWindowCenter</span> <span class="o">=</span> <span class="n">numberOfBasis</span> <span class="o">-</span> <span class="n">numberOfWindowsForUnit</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c">## center positions in number of frequency bins</span>
        <span class="n">sineCenters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>\
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">firstWindowCenter</span><span class="p">,</span> <span class="n">lastWindowCenter</span><span class="p">)</span> \
            <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">lengthSineWindow</span><span class="p">)</span> \
            <span class="o">+</span> <span class="n">lengthSineWindow</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        
        <span class="c"># For future purpose: to use different frequency scales</span>
        <span class="n">isScaleRecognized</span> <span class="o">=</span> <span class="bp">True</span>
        
    <span class="c"># For frequency scale in logarithm (such as ERB scales) </span>
    <span class="k">if</span> <span class="n">frequencyScale</span> <span class="o">==</span> <span class="s">&#39;log&#39;</span><span class="p">:</span>
        <span class="n">isScaleRecognized</span> <span class="o">=</span> <span class="bp">False</span>
        
    <span class="c"># checking whether the required scale is recognized</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">isScaleRecognized</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;The desired feature for frequencyScale &quot;</span> <span class="o">+</span> \
                                  <span class="s">&quot;is not recognized yet...&quot;</span><span class="p">)</span>
    
    <span class="c"># the shape of one window:</span>
    <span class="n">prototypeSineWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">lengthSineWindow</span><span class="p">)</span>
    <span class="c"># adding zeroes on both sides, such that we do not need to check</span>
    <span class="c"># for boundaries</span>
    <span class="n">bigWindow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">sizeBigWindow</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">bigWindow</span><span class="p">[(</span><span class="n">sizeBigWindow</span> <span class="o">-</span> <span class="n">lengthSineWindow</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">):</span>\
              <span class="p">(</span><span class="n">sizeBigWindow</span> <span class="o">+</span> <span class="n">lengthSineWindow</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)]</span> \
              <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">prototypeSineWindow</span><span class="p">)</span>
    
    <span class="n">WGAMMA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">numberFrequencyBins</span><span class="p">,</span> <span class="n">numberOfBasis</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numberOfBasis</span><span class="p">):</span>
        <span class="n">WGAMMA</span><span class="p">[:,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">bigWindow</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">mappingFrequency</span> \
                                                    <span class="o">-</span> <span class="n">sineCenters</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> \
                                                    <span class="o">+</span> <span class="n">sizeBigWindow</span><span class="p">)])</span>
        
    <span class="k">return</span> <span class="n">WGAMMA</span>


<span class="c">########## Main classes for audio models ##########</span>

<div class="viewcode-block" id="FASST"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST">[docs]</a><span class="k">class</span> <span class="nc">FASST</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;**FASST audio model**, from::</span>
<span class="sd">    </span>
<span class="sd">     A. Ozerov, E. Vincent and F. Bimbot</span>
<span class="sd">     \&quot;A General Flexible Framework for the Handling of Prior Information</span>
<span class="sd">     in Audio Source Separation,\&quot;  </span>
<span class="sd">     IEEE Transactions on Audio, Speech and Signal Processing 20(4),</span>
<span class="sd">     pp. 1118-1133 (2012)                            </span>
<span class="sd">     Available online: http://hal.inria.fr/hal-00626962/</span>
<span class="sd">    </span>
<span class="sd">    Adapted from the Matlab toolbox available at</span>
<span class="sd">    http://bass-db.gforge.inria.fr/fasst/</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># for now only stft:</span>
    <span class="n">implemented_transf</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;stft&#39;</span><span class="p">,</span><span class="s">&#39;stftold&#39;</span><span class="p">,</span> <span class="s">&#39;mqt&#39;</span><span class="p">,</span> <span class="s">&#39;minqt&#39;</span><span class="p">,</span> <span class="s">&#39;cqt&#39;</span><span class="p">]</span>
    <span class="n">implemented_annealing</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="s">&#39;no_ann&#39;</span><span class="p">,</span> <span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">audio</span><span class="p">,</span>
                 <span class="n">transf</span><span class="o">=</span><span class="s">&#39;stft&#39;</span><span class="p">,</span>
                 <span class="n">wlen</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
                 <span class="n">hopsize</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                 <span class="n">iter_num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">sim_ann_opt</span><span class="o">=</span><span class="s">&#39;ann&#39;</span><span class="p">,</span>
                 <span class="n">ann_PSD_lim</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">nmfUpdateCoeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                 <span class="n">tffmin</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                 <span class="n">tffmax</span><span class="o">=</span><span class="mi">18000</span><span class="p">,</span>
                 <span class="n">tfWinFunc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">tfbpo</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
                 <span class="n">lambdaCorr</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;**FASST**: Flexible Audio Source Separation Toolbox</span>
<span class="sd">        </span>
<span class="sd">        This is the superclass that implements the core functions for</span>
<span class="sd">        the framework for audio source separation as introduced in</span>
<span class="sd">            A. Ozerov, E. Vincent and F. Bimbot</span>
<span class="sd">            \&quot;A General Flexible Framework for the Handling of Prior</span>
<span class="sd">            Information in Audio Source Separation,\&quot; </span>
<span class="sd">            IEEE Transactions on Audio, Speech and Signal Processing 20(4),</span>
<span class="sd">            pp. 1118-1133 (2012)                            </span>
<span class="sd">            Available: http://hal.inria.fr/hal-00626962/</span>
<span class="sd">        </span>
<span class="sd">        In order to use it, one should sub-class this class, and in particular</span>
<span class="sd">        define several elements that are assumed by the core functions for</span>
<span class="sd">        estimation and separation in this class, namely:</span>
<span class="sd">        </span>
<span class="sd">        **ATTRIBUTES** (WIP)</span>
<span class="sd">        spat_comps</span>
<span class="sd">        </span>
<span class="sd">        spec_comps</span>
<span class="sd">        </span>
<span class="sd">        audioObject</span>
<span class="sd">            samplerate</span>
<span class="sd">            channels</span>
<span class="sd">            </span>
<span class="sd">        sig_repr_params</span>
<span class="sd">            &#39;transf&#39;</span>
<span class="sd">            &#39;wlen&#39;</span>
<span class="sd">            &#39;fsize&#39;</span>
<span class="sd">            &#39;hopsize&#39;</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        **ARGUMENT**</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmfUpdateCoeff</span> <span class="o">=</span> <span class="n">nmfUpdateCoeff</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span> <span class="o">=</span> <span class="n">audio</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">audio</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;The provided audio parameter is&quot;</span><span class="o">+</span>
                                 <span class="s">&quot;not a supported format.&quot;</span><span class="p">)</span>
        
        <span class="c"># parameters to compute the signal representation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transf</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c"># transformation type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">nextpow2</span><span class="p">(</span><span class="n">wlen</span><span class="p">)</span>      <span class="c"># window length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">nextpow2</span><span class="p">(</span><span class="n">wlen</span><span class="p">)</span> <span class="c"># Fourier length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hopsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tffmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tffmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfbpo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tfbpo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfWinFunc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tfWinFunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.</span> <span class="o">*</span> <span class="n">hopsize</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">implemented_transf</span> \
               <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tftransforms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="s">&quot; not yet implemented.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span> <span class="o">=</span> <span class="n">tftransforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]](</span>
                <span class="n">fmin</span><span class="o">=</span><span class="n">tffmin</span><span class="p">,</span>
                <span class="n">fmax</span><span class="o">=</span><span class="n">tffmax</span><span class="p">,</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">tfbpo</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">,</span>
                <span class="n">perfRast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">linFTLen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                <span class="n">atomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span> <span class="o">=</span> <span class="n">tftransforms</span><span class="p">[</span><span class="s">&#39;stft&#39;</span><span class="p">](</span>
                <span class="n">fmin</span><span class="o">=</span><span class="n">tffmin</span><span class="p">,</span>
                <span class="n">fmax</span><span class="o">=</span><span class="n">tffmax</span><span class="p">,</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">tfbpo</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">,</span>
                <span class="n">perfRast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">linFTLen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                <span class="n">atomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">],</span>
                <span class="p">)</span>
            
            
        <span class="c"># demix parameters:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;tffmin&#39;</span><span class="p">:</span> <span class="n">tffmin</span><span class="p">,</span> <span class="s">&#39;tffmax&#39;</span><span class="p">:</span> <span class="n">tffmax</span><span class="p">,</span>
            <span class="s">&#39;tfbpo&#39;</span><span class="p">:</span> <span class="n">tfbpo</span><span class="p">,</span>
            <span class="s">&#39;tfrepresentation&#39;</span><span class="p">:</span> <span class="n">transf</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="c"># &#39;stft&#39;, #transf.lower()</span>
            <span class="s">&#39;wlen&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">],</span>
            <span class="s">&#39;hopsize&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
            <span class="s">&#39;neighbors&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s">&#39;winFunc&#39;</span><span class="p">:</span> <span class="n">tfWinFunc</span><span class="p">,</span>
            <span class="p">}</span>
        
        <span class="c"># noise parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_ann_opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann_PSD_lim</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">=</span> <span class="n">iter_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">=</span> <span class="n">lambdaCorr</span>
    
<div class="viewcode-block" id="FASST.comp_transf_Cx"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.comp_transf_Cx">[docs]</a>    <span class="k">def</span> <span class="nf">comp_transf_Cx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the signal representation, according</span>
<span class="sd">        to the provided signal_representation flag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="p">,</span> <span class="s">&#39;_data&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">_read</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">implemented_transf</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">+</span>
                             <span class="s">&quot; not implemented - yet?&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Computing the chosen signal representation:&quot;</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="p">)</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">Xchan</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">n</span><span class="p">],)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
            <span class="n">Xchan</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="c">##assert self.nbFreqsSigRepr == self.tft.freqbins</span>
        <span class="k">del</span> <span class="n">X</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span>
        
        <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Xchan</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nc</span> <span class="o">*</span> <span class="p">(</span><span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                    <span class="c"># note : we keep only upper diagonal of Cx</span>
                    <span class="c"># lower diagonal is conjugate of upper one.</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">n1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xchan</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Xchan</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mix_psd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c"># average power, for each frequency band, across the frames</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mix_psd</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">n1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c"># n2 = n1</span>
                    <span class="n">mix_psd</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;mix_psd&quot;</span><span class="p">,</span> <span class="n">mix_psd</span>
            <span class="n">mix_psd</span> <span class="o">/=</span> <span class="n">nc</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;mix_psd/nc&quot;</span><span class="p">,</span> <span class="n">mix_psd</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mix_psd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mix_psd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10000.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;ann&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c"># useless for the rest of computations:</span>
        <span class="k">del</span> <span class="n">Xchan</span>
    </div>
<div class="viewcode-block" id="FASST.estim_param_a_post_model"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.estim_param_a_post_model">[docs]</a>    <span class="k">def</span> <span class="nf">estim_param_a_post_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;Estimates the _a posteriori_ model for the provided</span>
<span class="sd">        audio signal. In particular, this runs self.iter_num times</span>
<span class="sd">        the Generalized Expectation-Maximisation algorithm to</span>
<span class="sd">        update the various parameters of the model, so as to</span>
<span class="sd">        maximize the likelihood of the data given these parameters.</span>
<span class="sd">        </span>
<span class="sd">        From these parameters, the posterior expectation of the</span>
<span class="sd">        \&quot;hidden\&quot; or latent variables (here the spatial and spectral</span>
<span class="sd">        components) can be computed, leading to the estimation of the</span>
<span class="sd">        separated underlying sources.</span>

<span class="sd">        Consider using ``self.separate\_spat\_comps`` or</span>
<span class="sd">        ``self.separate\_spatial\_filter\_comp`` to obtain the separated time</span>
<span class="sd">        series, once the parameters have been estimated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">logliks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span>
        
        <span class="c"># TODO: move this back in __init__, and remove from subclasses...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="s">&#39;no_ann&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;To add noise to the signal, provide the &quot;</span><span class="o">+</span>
                          <span class="s">&quot;sim_ann_opt from any of &#39;ann&#39;, &quot;</span><span class="o">+</span>
                          <span class="s">&quot;&#39;no_ann&#39; or &#39;ann_ns_inj&#39; &quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Iteration&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span>
            <span class="c"># adding the noise psd if required:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="s">&#39;ann_ns_inj&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                
            <span class="c"># running the GEM iteration:</span>
            <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEM_iteration</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    log-likelihood:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        improvement:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">logliks</span>
    </div>
<div class="viewcode-block" id="FASST.GEM_iteration"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.GEM_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">GEM_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;GEM iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">retrieve_subsrc_params</span><span class="p">())</span>
            
            <span class="c"># compute the sufficient statistics</span>
            <span class="n">hat_Rxx</span><span class="p">,</span> <span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">hat_Ws</span><span class="p">,</span> <span class="n">loglik</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_suff_stat</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">))</span>
            
            <span class="c"># update the mixing matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_mix_matrix</span><span class="p">(</span><span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span><span class="p">)</span>
            
            <span class="c"># from sub-sources to sources</span>
            <span class="c"># (as given by the different spatial comps)</span>
            <span class="c">#     had better have shape = [nbSpatComps,F,N]</span>
            <span class="n">hat_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;rank_part_in&quot;</span><span class="p">,</span> <span class="n">rank_part_ind</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">)):</span>
                <span class="n">hat_W</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hat_Ws</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">w</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                
            <span class="k">del</span> <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span>
            <span class="k">del</span> <span class="n">hat_Rxx</span><span class="p">,</span> <span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">hat_Ws</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Nb channels &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">+</span>
                                 <span class="s">&quot; not implemented yet&quot;</span><span class="p">)</span>
        
        <span class="c"># update the spectral parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_spectral_components</span><span class="p">(</span><span class="n">hat_W</span><span class="p">)</span>
        
        <span class="c"># normalize parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">loglik</span>
    </div>
<div class="viewcode-block" id="FASST.comp_spat_comp_power"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.comp_spat_comp_power">[docs]</a>    <span class="k">def</span> <span class="nf">comp_spat_comp_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_comp_ind</span><span class="p">,</span>
                             <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[],</span> <span class="n">factor_ind</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matlab FASST Toolbox help::</span>
<span class="sd">        </span>
<span class="sd">        % V = comp_spat_comp_power(mix_str, spat_comp_ind,                  </span>
<span class="sd">        %                          spec_comp_ind, factor_ind);            </span>
<span class="sd">        %</span>
<span class="sd">        % compute spatial component power</span>
<span class="sd">        %</span>
<span class="sd">        %</span>
<span class="sd">        % input</span>
<span class="sd">        % -----</span>
<span class="sd">        %</span>
<span class="sd">        % mix_str           : mixture structure</span>
<span class="sd">        % spat_comp_ind     : spatial component index</span>
<span class="sd">        % spec_comp_ind     : (opt) factor index (def = [], use all components)</span>
<span class="sd">        % factor_ind         : (opt) factor index (def = [], use all factors)</span>
<span class="sd">        % </span>
<span class="sd">        %</span>
<span class="sd">        % output</span>
<span class="sd">        % ------</span>
<span class="sd">        %</span>
<span class="sd">        % V                 : (F x N) spatial component power</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp_ind</span><span class="p">):</span>
            <span class="n">spec_comp_ind_arr</span> <span class="o">=</span> <span class="n">spec_comp_ind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec_comp_ind_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spec_comp_ind_arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spat_comp_ind</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]:</span>
                <span class="n">V_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_ind</span><span class="p">):</span>
                    <span class="n">factors_ind_arr</span> <span class="o">=</span> <span class="n">factor_ind</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">factors_ind_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors_ind_arr</span><span class="p">:</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">f</span><span class="p">]</span>
                    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                    <span class="n">V_comp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">W</span>
                    <span class="k">del</span> <span class="n">H</span>
                    
                <span class="n">V</span> <span class="o">+=</span> <span class="n">V_comp</span>
                <span class="k">del</span> <span class="n">V_comp</span>
                <span class="k">del</span> <span class="n">factor</span>
        
        <span class="k">return</span> <span class="n">V</span>
    </div>
<div class="viewcode-block" id="FASST.comp_spat_cmps_powers"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.comp_spat_cmps_powers">[docs]</a>    <span class="k">def</span> <span class="nf">comp_spat_cmps_powers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_comp_ind</span><span class="p">,</span>
                              <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[],</span> <span class="n">factor_ind</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Compute the sum of the spectral powers corresponding to the</span>
<span class="sd">        spatial components as provided in the list `spat_comp_ind`</span>
<span class="sd">        </span>
<span class="sd">        NB: because this does not take into account the mixing process,</span>
<span class="sd">        the resulting power does not, in general, correspond to the</span>
<span class="sd">        the observed signal&#39;s parameterized spectral power.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spat_comp_ind</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span><span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">V</span>
    </div>
<div class="viewcode-block" id="FASST.retrieve_subsrc_params"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.retrieve_subsrc_params">[docs]</a>    <span class="k">def</span> <span class="nf">retrieve_subsrc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;Computes the various quantities necessary for the estimation of the</span>
<span class="sd">        main parameters:</span>
<span class="sd">        </span>
<span class="sd">        **Outputs**</span>
<span class="sd">        spat_comp_powers</span>
<span class="sd">            (total_spat_rank x nbFreqsSigRepr x nbFramesSigRepr) ndarray</span>
<span class="sd">            the spatial component power spectra. Note that total_spat_rank</span>
<span class="sd">            is the sum of all the spatial ranks for all the sources.</span>
<span class="sd">        mix_matrix</span>
<span class="sd">            (total_spat_rank x nchannels x nbFreqsSigRepr) ndarray</span>
<span class="sd">            the mixing matrices for each source</span>
<span class="sd">        rank_part_ind</span>
<span class="sd">            dictionary: each key is one source, and the values are the indices</span>
<span class="sd">            in spat_comp_powers and mix_matrix that correspond to that source.</span>
<span class="sd">            If the spatial rank of source j is 2, then its spectra will appear</span>
<span class="sd">            twice in spat_comp_powers, with mixing parameters (potentially</span>
<span class="sd">            different one from the other) appearing in two sub-matrices of</span>
<span class="sd">            mix_matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)</span>
        <span class="n">rank_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rank_part_ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="c"># this is the ranks</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Rank of spatial source </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">j</span> <span class="o">+</span>\
                      <span class="s">&quot; is </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">rank</span>
            <span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">rank_total</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rank</span><span class="p">))</span>
            <span class="n">rank_total</span> <span class="o">+=</span> <span class="n">rank</span>
        
        <span class="n">spat_comp_powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">rank_total</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        
        <span class="n">mix_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">rank_total</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spat_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spat_comp_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span><span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">spat_comp_j</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="c">#print rank_part_ind[j]</span>
                    <span class="c">#print spat_comp[&#39;params&#39;].shape</span>
                    <span class="c">#print mix_matrix[rank_part_ind[j],:,f].shape</span>
                    <span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">],:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                
        <span class="k">return</span> <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span>
    </div>
<div class="viewcode-block" id="FASST.compute_suff_stat"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.compute_suff_stat">[docs]</a>    <span class="k">def</span> <span class="nf">compute_suff_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Outputs:</span>
<span class="sd">        hat_Rxx</span>
<span class="sd">        hat_Rxs</span>
<span class="sd">        hat_Rss</span>
<span class="sd">        hat_Ws</span>
<span class="sd">        loglik</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Nb channels not supported:&quot;</span><span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;    Computing sufficient statistics&quot;</span>
        <span class="n">nbspatcomp</span> <span class="o">=</span> <span class="n">spat_comp_powers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">sigma_x_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">sigma_x_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">])</span>
            <span class="c"># noise PSD should be of size nbFreqs</span>
        
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">sigma_x_off</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            
        <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span><span class="p">,</span> <span class="n">det_sigma_x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inv_herm_mat_2d</span><span class="p">(</span><span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span>
        
        <span class="c"># compute log likelihood</span>
        <span class="n">loglik</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det_sigma_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span>
                           <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                           <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                           <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">inv_sigma_x_off</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                           <span class="p">)</span>
        <span class="c"># compute expectations of Rss and Ws sufficient statistics</span>
        <span class="n">Gs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># one for each channel (stereo, here)</span>
        <span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_sigma_x_off</span><span class="p">))</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            
            <span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_sigma_x_off</span> <span class="o">+</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            
        <span class="n">hat_Rss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                            <span class="n">nbspatcomp</span><span class="p">,</span>
                            <span class="n">nbspatcomp</span><span class="p">],</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">hat_Ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbspatcomp</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">hatRssLoc1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hatRssLoc2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hatRssLoc3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
                <span class="c"># TODO: could probably factor a bit more the following formula:</span>
                <span class="c">## hatRssLoc1[:] = (Gs[0][r1] * np.conj(Gs[0][r2]) * self.Cx[0] + Gs[1][r1] * np.conj(Gs[1][r2]) * self.Cx[2] +Gs[0][r1] * np.conj(Gs[1][r2]) * self.Cx[1] +Gs[1][r1] * np.conj(Gs[0][r2]) *np.conj(self.Cx[1]) -(Gs[0][r1] * np.vstack(mix_matrix[r2][0]) + Gs[1][r1] * np.vstack(mix_matrix[r2][1])) *spat_comp_powers[r2]  )</span>
                <span class="n">hatRssLoc1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">hatRssLoc1</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r2</span><span class="p">])</span>
                <span class="n">hatRssLoc1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r2</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">hatRssLoc1</span> <span class="o">*=</span> <span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r1</span><span class="p">]</span>
                
                <span class="n">hatRssLoc2</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">hatRssLoc2</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r2</span><span class="p">])</span>
                <span class="n">hatRssLoc2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">hatRssLoc2</span> <span class="o">*=</span> <span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r1</span><span class="p">]</span>
                
                <span class="n">hatRssLoc3</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r1</span><span class="p">])</span>
                <span class="n">hatRssLoc3</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">hatRssLoc3</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r2</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">hatRssLoc3</span> <span class="o">*=</span> <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span>
                
                <span class="n">hatRssLoc1</span> <span class="o">+=</span> <span class="n">hatRssLoc2</span>
                <span class="n">hatRssLoc1</span> <span class="o">-=</span> <span class="n">hatRssLoc3</span>
                
                <span class="c">#hatRssLoc = (Gs[0][r1] * np.conj(Gs[0][r2]) * self.Cx[0] +</span>
                <span class="c">#             Gs[1][r1] * np.conj(Gs[1][r2]) * self.Cx[2] +</span>
                <span class="c">#             Gs[0][r1] * np.conj(Gs[1][r2]) * self.Cx[1] +</span>
                <span class="c">#             Gs[1][r1] * np.conj(Gs[0][r2]) * np.conj(self.Cx[1]) -</span>
                <span class="c">#             (Gs[0][r1] * np.vstack(mix_matrix[r2][0]) +</span>
                <span class="c">#              Gs[1][r1] * np.vstack(mix_matrix[r2][1]))</span>
                <span class="c">#             * spat_comp_powers[r2]</span>
                <span class="c">#             )</span>
                <span class="k">if</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span><span class="p">:</span>
                    <span class="n">hatRssLoc1</span> <span class="o">+=</span> <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span>
                    <span class="n">hat_Ws</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hatRssLoc1</span><span class="p">))</span>
                    
                <span class="n">hat_Rss</span><span class="p">[:,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hatRssLoc1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                
        <span class="c"># To assure hermitian symmetry:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
            <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            
        <span class="c"># Expectations of Rxs sufficient statistics</span>
        <span class="n">hat_Rxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                            <span class="mi">2</span><span class="p">,</span>
                            <span class="n">nbspatcomp</span><span class="p">],</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="n">hat_Rxs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">hat_Rxs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
        
        <span class="k">del</span> <span class="n">Gs</span>
        
        <span class="c"># at last Rxx sufficient statistics:</span>
        <span class="n">hat_Rxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># recommendation, use logarithm:</span>
        <span class="c"># hat_Rxx[]</span>
        
        <span class="k">return</span> <span class="n">hat_Rxx</span><span class="p">,</span> <span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">hat_Ws</span><span class="p">,</span> <span class="n">loglik</span>
    </div>
<div class="viewcode-block" id="FASST.inv_herm_mat_2d"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.inv_herm_mat_2d">[docs]</a>    <span class="k">def</span> <span class="nf">inv_herm_mat_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the inverse of 2D hermitian matrices.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        sigma_x_diag</span>
<span class="sd">            ndarray, with (dim of axis=0) = 2</span>
<span class="sd">            </span>
<span class="sd">            The diagonal elements of the matrices to invert.</span>
<span class="sd">            sigma_x_diag[0] are the (0,0) elements and</span>
<span class="sd">            sigma_x_diag[1] are the (1,1) ones.</span>
<span class="sd">            </span>
<span class="sd">        sigma_x_off</span>
<span class="sd">            ndarray, with the same dimensions as sigma_x_diag[0]</span>
<span class="sd">            </span>
<span class="sd">            The off-diagonal elements of the matrices, more precisely the</span>
<span class="sd">            (0,1) element (since the matrices are assumed Hermitian,</span>
<span class="sd">            the (1,0) element is the complex conjugate)</span>
<span class="sd">        </span>
<span class="sd">        Outputs</span>
<span class="sd">        -------</span>
<span class="sd">        inv_sigma_x_diag</span>
<span class="sd">            ndarray, 2 x shape(sigma_x_off)</span>

<span class="sd">            Diagonal elements of the inverse matrices.</span>
<span class="sd">            [0] &lt;-&gt; (0,0)</span>
<span class="sd">            [1] &lt;-&gt; (1,1)</span>

<span class="sd">        inv_sigma_x_off</span>
<span class="sd">            ndarray, shape(sigma_x_off)</span>
<span class="sd">            </span>
<span class="sd">            Off-diagonal (0,1) elements of the inverse matrices</span>

<span class="sd">        det_sigma_x</span>
<span class="sd">            ndarray, shape(sigma_x_off)</span>
<span class="sd">            </span>
<span class="sd">            For each inversion, the determinant of the matrix.</span>
<span class="sd">        </span>
<span class="sd">        Remarks</span>
<span class="sd">        -------</span>
<span class="sd">        The inversion is done explicitly, by computing the determinant</span>
<span class="sd">        (explicit formula for 2D matrices), then the elements of the</span>
<span class="sd">        inverse with the corresponding formulas.</span>
<span class="sd">        </span>
<span class="sd">        To deal with ill-conditioned matrices, a minimum (absolute) value of</span>
<span class="sd">        the determinant is guaranteed. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#if len(sigma_x_diag.shape) != 3:</span>
        <span class="c">#    raise ValueError(&quot;Something weird happened to sigma_x&quot;)</span>
        <span class="n">det_sigma_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma_x_off</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;number of 0s in det &quot;</span><span class="p">,(</span><span class="n">det_sigma_x</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c"># issue when det sigma x is 0... </span>
        <span class="n">det_sigma_x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">det_sigma_x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">det_sigma_x</span><span class="p">),</span> <span class="n">eps</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;number of 0s left in det&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">det_sigma_x</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">inv_sigma_x_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sigma_x_diag</span><span class="p">)</span>
        <span class="n">inv_sigma_x_off</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sigma_x_off</span> <span class="o">/</span> <span class="n">det_sigma_x</span>
        <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">det_sigma_x</span>
        <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">det_sigma_x</span>
        
        <span class="k">return</span> <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span><span class="p">,</span> <span class="n">det_sigma_x</span>
    </div>
<div class="viewcode-block" id="FASST.update_mix_matrix"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.update_mix_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">update_mix_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># deriving which components have which updating rule:</span>
        <span class="n">upd_inst_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">upd_inst_other_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">upd_conv_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">upd_conv_other_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spat_comp_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span> <span class="ow">and</span> \
                   <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">upd_inst_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upd_inst_other_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span> <span class="ow">and</span> \
                   <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;conv&#39;</span><span class="p">:</span>
                <span class="n">upd_conv_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upd_conv_other_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        
        <span class="c"># update linear instantaneous coefficients:</span>
        <span class="n">K_inst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_inst_ind</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_inst_ind</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Updating mixing matrix, instantaneous sources&quot;</span>
            <span class="c">#hat_Rxs_bis = np.zeros([self.nbFreqsSigRepr,</span>
            <span class="c">#                        2,</span>
            <span class="c">#                        K_inst])</span>
            <span class="n">hat_Rxs_bis</span> <span class="o">=</span> <span class="n">hat_Rxs</span><span class="p">[:,:,</span><span class="n">upd_inst_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_inst_other_ind</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_inst_other_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">upd_inst_other_ind</span><span class="p">),</span>
                                                        <span class="n">upd_inst_ind</span><span class="p">]))</span>
                    <span class="c"># hat_Rss[f][upd_inst_other_ind][:,upd_inst_ind])</span>
            <span class="n">hat_Rxs_bis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hat_Rxs_bis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">rm_hat_Rss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">upd_inst_ind</span><span class="p">),</span>
                                                 <span class="n">upd_inst_ind</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            
            <span class="c"># in ozerov&#39;s code:</span>
            <span class="c">##mix_matrix_inst = np.dot(hat_Rxs_bis, np.linalg.inv(rm_hat_Rss))</span>
            <span class="n">mix_matrix_inst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rm_hat_Rss</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">hat_Rxs_bis</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c">#                                   sym_pos=True).T</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;mix_matrix&quot;</span><span class="p">,</span> <span class="n">mix_matrix</span>
                <span class="k">print</span> <span class="s">&quot;mix_matrix_inst&quot;</span><span class="p">,</span> <span class="n">mix_matrix_inst</span>
                <span class="k">print</span> <span class="s">&quot;mix_matrix_inst.shape&quot;</span><span class="p">,</span><span class="n">mix_matrix_inst</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">print</span> <span class="n">mix_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> \
                      <span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_inst_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                <span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_inst_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_matrix_inst</span>
                
            <span class="k">del</span> <span class="n">mix_matrix_inst</span>
            
        <span class="c"># update convolutive coefficients: </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_conv_ind</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Updating mixing matrix, convolutive sources&quot;</span>
            <span class="n">hat_Rxs_bis</span> <span class="o">=</span> <span class="n">hat_Rxs</span><span class="p">[:,:,</span><span class="n">upd_conv_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_conv_other_ind</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_conv_other_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">upd_conv_other_ind</span><span class="p">),</span>
                                          <span class="n">upd_conv_ind</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_conv_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;hat_Rss[f]:&quot;</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
                    <span class="k">print</span> <span class="s">&quot;hat_Rxs_bis[f]:&quot;</span><span class="p">,</span> <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
                    <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s">&#39;Singular Matrix&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="c"># re-raise the exception if that was not linalgerror...</span>
                    
            <span class="c">## smoothing</span>
            <span class="c">##for n in upd_conv_ind:</span>
            <span class="c">##    for nc in range(self.audioObject.channels):</span>
            <span class="c">##        smoothAbsMix = (</span>
            <span class="c">##            st.medianFilter(np.abs(mix_matrix[n,nc,:]),</span>
            <span class="c">##                            length=self.nbFreqsSigRepr/200)</span>
            <span class="c">##            )</span>
            <span class="c">##        mix_matrix[n,nc,:] = (</span>
            <span class="c">##            smoothAbsMix *</span>
            <span class="c">##            np.exp(1j * np.angle(mix_matrix[n,nc,:]))</span>
            <span class="c">##            )</span>
            
        <span class="c"># update the matrix in the component parameters:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">spat_comp_k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                    <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                    
        <span class="c"># mix_matrix should have changed outside this method... TBC</span>
        <span class="c"># should we normalize here?</span>
        <span class="c">##self.renormalize_parameters()</span>
        </div>
<div class="viewcode-block" id="FASST.separate_spatial_filter_comp"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.separate_spatial_filter_comp">[docs]</a>    <span class="k">def</span> <span class="nf">separate_spatial_filter_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                     <span class="n">dir_results</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                     <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separate_spatial_filter_comp</span>
<span class="sd">        </span>
<span class="sd">        Separates the sources using only the estimated spatial</span>
<span class="sd">        filter (i.e. the mixing parameters in self.spat_comps[j][&#39;params&#39;])</span>
<span class="sd">        </span>
<span class="sd">        In particular, we consider here the corresponding MVDR filter,</span>
<span class="sd">        as exposed in::</span>
<span class="sd">        </span>
<span class="sd">         Maazaoui, M.; Grenier, Y. &amp; Abed-Meraim, K.</span>
<span class="sd">         ``Blind Source Separation for Robot Audition using</span>
<span class="sd">         Fixed Beamforming with HRTFs&#39;&#39;, </span>
<span class="sd">         in proc. of INTERSPEECH, 2011.</span>
<span class="sd">        </span>
<span class="sd">        per channel, the filter steering vector, source p:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            b(f,p) = \\frac{R_{aa,f}^{-1} a(f,p)}{a^{H}(f,p) R_{aa,f}^{-1} a(f,p)}</span>
<span class="sd">            </span>
<span class="sd">        with</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            R_{aa,f} = \\sum_q a(f,q) a^{H}(f,q)</span>
<span class="sd">            </span>
<span class="sd">        It corresponds also to the given model in FASST, assuming that all the</span>
<span class="sd">        spectral powers are equal across all sources. Here, by computing the Wiener</span>
<span class="sd">        Gain WG to get the images, we actually have</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            b(f,p) a(f,p)^H</span>
<span class="sd">            </span>
<span class="sd">        and the denominator therefore is the trace of the \&quot;numerator\&quot;.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># grouping the indices by spatial component</span>
        <span class="n">spec_comp_ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">spat_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)):</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c"># add the spec comp index to the corresponding spatial comp:</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec_ind</span><span class="p">)</span>
            
        <span class="c"># copying from separate_spec_comps -  could modify that one later...</span>
        <span class="k">if</span> <span class="n">dir_results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dir_results</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Writing to same directory as input file: &quot;</span> <span class="o">+</span> <span class="n">dir_results</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">nc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        
        <span class="n">nbSources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp_ind</span><span class="p">)</span>
        <span class="n">sigma_comps_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">sigma_comps_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="c"># computing individual spatial variance</span>
        <span class="n">R_diag0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">])</span>
        <span class="n">R_diag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">])</span>
        <span class="n">R_off</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Mixing params not convolutive...&#39;</span><span class="p">)</span>
                <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="c"># mix_coefficients.shape should be (rank, nchannels)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;conv&#39;</span><span class="p">:</span>
                <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                <span class="c"># mix_coefficients.shape should be (rank, nchannels, freq)</span>
            
            <span class="c"># R_diag = np.zeros(2, self.nbFreqsSigRepr)</span>
            <span class="n">R_diag0</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">R_diag1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="c"># element at (1,2): </span>
            <span class="n">R_off</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span>
                <span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            
        <span class="n">Raa_00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R_diag0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Raa_11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R_diag1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Raa_01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R_off</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inv_Raa_diag</span><span class="p">,</span> <span class="n">inv_Raa_off</span><span class="p">,</span> <span class="n">det_mat</span> <span class="o">=</span> <span class="n">inv_mat</span><span class="p">([</span><span class="n">Raa_00</span><span class="p">,</span> <span class="n">Raa_11</span><span class="p">],</span>
                                                     <span class="n">Raa_01</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;files&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="p">{}</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spatial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">fileroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
            <span class="n">WG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_Wiener_gain_2d</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">R_diag0</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">R_diag1</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span>
                    <span class="n">R_off</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">inv_Raa_diag</span><span class="p">,</span>
                    <span class="n">inv_Raa_off</span><span class="p">,</span>
                <span class="n">timeInvariant</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">WG</span> <span class="o">/=</span> <span class="p">[[</span><span class="n">normalization</span><span class="p">]]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
                <span class="c"># compute the stft/istft</span>
                <span class="n">ndata</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">filter_stft</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">WG</span><span class="p">,</span> <span class="n">analysisWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">synthWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#raise NotImplementedError(&quot;TODO&quot;)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">chan1</span><span class="p">])</span>
                    <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span>
                <span class="n">ndata</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">])</span>
                                <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                        <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                <span class="k">elif</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">]</span>
                                <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                        <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                        
                <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                
            <span class="n">_suffix</span> <span class="o">=</span> <span class="s">&#39;_spatial&#39;</span>
            <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="n">_suffix</span> <span class="o">+=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">outAudioName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dir_results</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="n">fileroot</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> 
                <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nbSources</span><span class="p">)</span> <span class="o">+</span> <span class="n">_suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spatial&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outAudioName</span><span class="p">)</span>
            <span class="n">outAudioObj</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">outAudioName</span><span class="p">,</span>
                                         <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span>
                <span class="n">ndata</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">nframes</span><span class="p">,:]</span> <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">_maxdata</span><span class="p">)</span><span class="c">#(2**15))</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_maxdata</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="s">&#39;pcm16&#39;</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">samplerate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_write</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="FASST.separate_spat_comps"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.separate_spat_comps">[docs]</a>    <span class="k">def</span> <span class="nf">separate_spat_comps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">dir_results</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separate_spat_comps</span>
<span class="sd">        </span>
<span class="sd">        This separates the sources for each spatial component.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec_comp_ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">spat_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)):</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec_ind</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_comps</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="n">spec_comp_ind</span><span class="p">,</span>
                            <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="FASST.separate_comps"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.separate_comps">[docs]</a>    <span class="k">def</span> <span class="nf">separate_comps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">dir_results</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">spec_comp_ind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separate_comps</span>
<span class="sd">        </span>
<span class="sd">        Separate the sources as defined by the spectral</span>
<span class="sd">        components provided in spec_comp_ind.</span>
<span class="sd">        </span>
<span class="sd">        This function differs from separate_spat_comps in the way</span>
<span class="sd">        that it does not assume the sources are defined by their spatial</span>
<span class="sd">        positions.</span>
<span class="sd">        </span>
<span class="sd">        Note: Trying to bring into one method</span>
<span class="sd">        ozerov&#39;s separate_spec_comps and separate_spat_comps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dir_results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dir_results</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Writing to same directory as input file: &quot;</span> <span class="o">+</span> <span class="n">dir_results</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">nc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">spec_comp_ind</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">spec_comp_ind</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">spec_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">)):</span>
                <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec_ind</span><span class="p">,]</span>
        
        <span class="n">nbSources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp_ind</span><span class="p">)</span>
        <span class="n">sigma_comps_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">sigma_comps_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="c"># computing individual source variance</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;    source&quot;</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;out of&quot;</span><span class="p">,</span><span class="n">nbSources</span>
            <span class="n">spat_comp_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">spec_ind</span> <span class="ow">in</span> <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;        spat_comp_ind&quot;</span><span class="p">,</span> <span class="n">spat_comp_ind</span>
            <span class="k">for</span> <span class="n">spat_ind</span> <span class="ow">in</span> <span class="n">spat_comp_ind</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        spatial comp&quot;</span><span class="p">,</span><span class="n">spat_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> \
                          <span class="s">&quot;out of&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_comp_ind</span><span class="p">)</span>
                <span class="n">sigma_c_diag</span><span class="p">,</span> <span class="n">sigma_c_off</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">compute_sigma_comp_2d</span><span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="n">sigma_comps_diag</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_c_diag</span>
                <span class="n">sigma_comps_off</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_c_off</span>
                <span class="k">del</span> <span class="n">sigma_c_diag</span><span class="p">,</span> <span class="n">sigma_c_off</span>
        <span class="c"># deriving inverse of mix covariance:</span>
        <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_inv_sigma_mix_2d</span><span class="p">(</span>
            <span class="n">sigma_comps_diag</span><span class="p">,</span>
            <span class="n">sigma_comps_off</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;files&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spat_comp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="bp">True</span><span class="p">:</span> <span class="c"># self # IF TRANSFO is STFT !!!... 20130507 corrected now?</span>
            <span class="n">fileroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
                <span class="c"># get the Wiener filters:</span>
                <span class="n">WG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_Wiener_gain_2d</span><span class="p">(</span>
                    <span class="n">sigma_comps_diag</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">sigma_comps_off</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">inv_sigma_x_diag</span><span class="p">,</span>
                    <span class="n">inv_sigma_x_off</span><span class="p">)</span>
                <span class="c"># compute the stft/istft</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">filter_stft</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">WG</span><span class="p">,</span> <span class="n">analysisWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">synthWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
                        <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                        <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                        <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">chan1</span><span class="p">])</span>
                        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">])</span>
                                    <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                            <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                    <span class="k">elif</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">]</span>
                                    <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                            <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                        
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">_suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">suffix</span><span class="p">:</span>
                    <span class="n">_suffix</span> <span class="o">=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">outAudioName</span> <span class="o">=</span> \
                    <span class="n">dir_results</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="n">fileroot</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nbSources</span><span class="p">)</span> <span class="o">+</span> <span class="n">_suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spat_comp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outAudioName</span><span class="p">)</span>
                <span class="n">outAudioObj</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">outAudioName</span><span class="p">,</span>
                                             <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span>
                    <span class="n">ndata</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">nframes</span><span class="p">,:]</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">_maxdata</span><span class="p">)</span><span class="c">#(2**15))</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_maxdata</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="s">&#39;pcm16&#39;</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">samplerate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_write</span><span class="p">()</span>
        <span class="c">## TODO: else for the other transforms</span>
        <span class="c">##       should work all the same, but with cqt, not very good</span>
        <span class="c">## means to cut signals and paste them back together...</span>
        </div>
<div class="viewcode-block" id="FASST.mvdr_2d"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.mvdr_2d">[docs]</a>    <span class="k">def</span> <span class="nf">mvdr_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">theta</span><span class="p">,</span>
                <span class="n">distanceInterMic</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;mvdr_2d(self,</span>
<span class="sd">        theta, # in radians</span>
<span class="sd">        distanceInterMic=.3, # in meters</span>
<span class="sd">        )</span>
<span class="sd">        </span>
<span class="sd">        MVDR minimum variance distortion-less response spatial</span>
<span class="sd">        filter, for a given angle theta and given distance between the mics.</span>
<span class="sd">        </span>
<span class="sd">        self.Cx is supposed to provide the necessary covariance matrix, for</span>
<span class="sd">        the \&quot;Capon\&quot; filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">)</span>
        <span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">Cx</span>
        
        <span class="c">#inv_Cx_diag, inv_Cx_off, det_Cx = self.inv_herm_mat_2d([self.Cx[0],</span>
        <span class="c">#                                                        self.Cx[2]],</span>
        <span class="c">#                                                       self.Cx[1])</span>
        <span class="n">inv_Cx_diag</span><span class="p">,</span> <span class="n">inv_Cx_off</span><span class="p">,</span> <span class="n">det_Cx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_herm_mat_2d</span><span class="p">([</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                <span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                                                               <span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
            <span class="p">)</span>
        
        <span class="n">filt</span> <span class="o">=</span> <span class="n">gen_steer_vec_far_src_uniform_linear_array</span><span class="p">(</span>
                   <span class="n">freqs</span><span class="p">,</span>
                   <span class="n">nchannels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span>
                   <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                   <span class="n">distanceInterMic</span><span class="o">=</span><span class="n">distanceInterMic</span><span class="p">)</span>
        
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="c"># nc x nc x F x N</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="n">den</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">inv_Cx_off</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_Cx_off</span>
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_off</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_Cx_off</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="c">#if self.verbose&gt;1:</span>
        <span class="c">#    print W</span>
        <span class="c"># should check that self.sig_repr_params[&#39;transf&#39;] == &#39;stft&#39;</span>
        <span class="k">return</span> <span class="n">ao</span><span class="o">.</span><span class="n">filter_stft</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">analysisWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
            <span class="n">synthWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
            <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
            <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
            <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="FASST.gcc_phat_tdoa_2d"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.gcc_phat_tdoa_2d">[docs]</a>    <span class="k">def</span> <span class="nf">gcc_phat_tdoa_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Using the cross-spectrum in self.Cx[1] to estimate the time</span>
<span class="sd">        difference of arrival detection function (the Generalized Cross-</span>
<span class="sd">        Correllation GCC), with the phase transform (GCC-PHAT) weighing</span>
<span class="sd">        function for the cross-spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
<span class="c">##    # separate individual components:</span>
<span class="c">##    def separate_spec_comp(self, sep_comp_ind, *args, **kwargs):</span>
<span class="c">##        &quot;&quot;&quot;</span>
<span class="c">##        &quot;&quot;&quot;</span>
<span class="c">##        return self.separate_comp(sep_comp_ind)</span>
    
<span class="c">##    def separate_spat_comp(self, spat_comp_ind, *args, **kwargs):</span>
<span class="c">##        &quot;&quot;&quot;</span>
<span class="c">##        ARGUMENTS</span>
<span class="c">##        ---------</span>
<span class="c">##        spat_comp_ind a list of the spatial components to separate</span>
<span class="c">##            the returned </span>
<span class="c">##        &quot;&quot;&quot;</span>
<span class="c">##        spec_comp_ind = []</span>
        
<span class="c">##        for spec_ind, spec_comp in self.spec_comps:</span>
<span class="c">##            if spec_comp[&#39;spat_comp_ind&#39;] in spat_comp_ind:</span>
<span class="c">##                spec_comp_ind.append(spec_ind)</span>
        
<span class="c">##        return self.separate_comp(spec_comp_ind, *args, **kwargs)</span>
    
<span class="c">##    def separate_comp(self, spec_comp_ind, filename):</span>
<span class="c">##        &quot;&quot;&quot;computes the wiener gain for the source represented by</span>
<span class="c">##        the spectral components listed in spec_comp_ind, then</span>
<span class="c">##        computes the time series and writes the output to filename.</span>
<span class="c">##        &quot;&quot;&quot;</span>
<span class="c">##        if len(spec_comp_ind):</span>
<span class="c">##            pass</span>
    </div>
<div class="viewcode-block" id="FASST.compute_sigma_comp_2d"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.compute_sigma_comp_2d">[docs]</a>    <span class="k">def</span> <span class="nf">compute_sigma_comp_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_ind</span><span class="p">,</span> <span class="n">spec_comp_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;only for stereo case self.audioObject.channels==2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
            <span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">spat_ind</span><span class="p">,</span>
            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="n">spec_comp_ind</span><span class="p">)</span>
        
        <span class="c"># getting the mixing coefficients for corresponding</span>
        <span class="c"># spatial source, depending on mix_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
            <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="c"># mix_coefficients.shape should be (rank, nchannels)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;conv&#39;</span><span class="p">:</span>
            <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
            <span class="c"># mix_coefficients.shape should be (rank, nchannels, freq)</span>
        
        <span class="c"># R_diag = np.zeros(2, self.nbFreqsSigRepr)</span>
        <span class="n">R_diag0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">R_diag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c"># element at (1,2): </span>
        <span class="n">R_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span>
            <span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
            <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="n">sigma_comp_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">R_diag0</span><span class="p">,</span> <span class="s">&quot;R_diag0.shape&quot;</span><span class="p">,</span> <span class="n">R_diag0</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">print</span> <span class="n">R_diag1</span><span class="p">,</span> <span class="s">&quot;R_diag1.shape&quot;</span><span class="p">,</span> <span class="n">R_diag1</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">print</span> <span class="n">R_off</span><span class="p">,</span> <span class="s">&quot;R_off.shape&quot;</span><span class="p">,</span> <span class="n">R_off</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">R_diag0</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">spat_comp_power</span><span class="p">)</span>
        <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">R_diag1</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">spat_comp_power</span><span class="p">)</span>
        
        <span class="n">sigma_comp_off</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">R_off</span><span class="p">)</span> <span class="o">*</span> <span class="n">spat_comp_power</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sigma_comp_diag</span><span class="p">,</span> <span class="n">sigma_comp_off</span>
    </div>
<div class="viewcode-block" id="FASST.compute_inv_sigma_mix_2d"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.compute_inv_sigma_mix_2d">[docs]</a>    <span class="k">def</span> <span class="nf">compute_inv_sigma_mix_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">sigma_comps_diag</span><span class="p">,</span>
                                 <span class="n">sigma_comps_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;only for nb channels = 2</span>
<span class="sd">        </span>
<span class="sd">        sigma_comps_diag ncomp x nchan x nfreq x nframes</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_x_diag</span> <span class="o">=</span> <span class="n">sigma_comps_diag</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sigma_x_off</span> <span class="o">=</span> <span class="n">sigma_comps_off</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">])</span>
            <span class="c"># noise PSD should be of size nbFreqs</span>
        
        <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inv_herm_mat_2d</span><span class="p">(</span><span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span><span class="p">))</span>
        
        <span class="k">del</span> <span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span>
        
        <span class="k">return</span> <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span>
    </div>
<div class="viewcode-block" id="FASST.compute_Wiener_gain_2d"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.compute_Wiener_gain_2d">[docs]</a>    <span class="k">def</span> <span class="nf">compute_Wiener_gain_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">sigma_comp_diag</span><span class="p">,</span>
                               <span class="n">sigma_comp_off</span><span class="p">,</span>
                               <span class="n">inv_sigma_mix_diag</span><span class="p">,</span>
                               <span class="n">inv_sigma_mix_off</span><span class="p">,</span>
                               <span class="n">timeInvariant</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matlab FASST Toolbox help::</span>
<span class="sd">        </span>
<span class="sd">            % WG = comp_WG_spat_comps(mix_str);</span>
<span class="sd">            %</span>
<span class="sd">            % compute Wiener gains for spatial components</span>
<span class="sd">            %</span>
<span class="sd">            %</span>
<span class="sd">            % input</span>
<span class="sd">            % -----</span>
<span class="sd">            %</span>
<span class="sd">            % mix_str           : input mix structure</span>
<span class="sd">            % </span>
<span class="sd">            %</span>
<span class="sd">            % output</span>
<span class="sd">            % ------</span>
<span class="sd">            %</span>
<span class="sd">            % WG                : Wiener gains [M x M x F x N x K_spat]</span>
<span class="sd">            %</span>
<span class="sd">            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="sd">            % Flexible Audio Source Separation Toolbox (FASST), Version 1.0</span>
<span class="sd">            %</span>
<span class="sd">            % Copyright 2011 Alexey Ozerov, Emmanuel Vincent and Frederic Bimbot</span>
<span class="sd">            % (alexey.ozerov -at- inria.fr, emmanuel.vincent -at- inria.fr,</span>
<span class="sd">            %  frederic.bimbot -at- irisa.fr)     </span>
<span class="sd">            %</span>
<span class="sd">            % This software is distributed under the terms of the GNU Public </span>
<span class="sd">            % License version 3 (http://www.gnu.org/licenses/gpl.txt)</span>
<span class="sd">            %</span>
<span class="sd">            % If you use this code please cite this research report</span>
<span class="sd">            %</span>
<span class="sd">            % A. Ozerov, E. Vincent and F. Bimbot</span>
<span class="sd">            % \&quot;A General Flexible Framework for the Handling of Prior</span>
<span class="sd">            % Information in Audio Source Separation,\&quot; </span>
<span class="sd">            % IEEE Transactions on Audio, Speech and Signal Processing 20(4),</span>
<span class="sd">            % pp. 1118-1133 (2012).</span>
<span class="sd">            % Available: http://hal.inria.fr/hal-00626962/</span>
<span class="sd">            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Here, WG is given by the product:</span>
        <span class="c">#     np.dot(sigma_comp</span>
        <span class="k">if</span> <span class="n">timeInvariant</span><span class="p">:</span>
            <span class="n">WG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="c"># stands for Wiener Gains</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">WG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="c"># stands for Wiener Gains</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_comp_off</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_sigma_mix_off</span><span class="p">)</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_sigma_mix_off</span> <span class="o">+</span>
            <span class="n">sigma_comp_off</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">sigma_comp_off</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_sigma_mix_off</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">WG</span>
    </div>
<div class="viewcode-block" id="FASST.update_spectral_components"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.update_spectral_components">[docs]</a>    <span class="k">def</span> <span class="nf">update_spectral_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hat_W</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the spectral components,</span>
<span class="sd">        with hat_W as the expected value of power</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    Update the spectral components&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmfUpdateCoeff</span>
        <span class="n">nbspeccomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nbfactors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">])</span>
            <span class="n">spat_comp_ind</span> <span class="o">=</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span>
            
            <span class="c"># DEBUG</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># min inter-src correlation approach</span>
                <span class="c"># this is the sum of all the spatial component powers</span>
                <span class="n">spat_comp_powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_cmps_powers</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">eps</span><span class="p">)</span>
                <span class="c">### we need the squared of that matrix too:</span>
                <span class="c">##spat_comp_powers_sqd = spat_comp_powers ** 2</span>
                <span class="c"># the initial spatial comp. power of the current comp:</span>
                <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                            <span class="n">spat_comp_ind</span><span class="p">,</span>
                            <span class="c">#spec_comp_ind=[spec_comp_ind],</span>
                            <span class="p">),</span>
                        <span class="n">eps</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="c"># ... and removing from the other powers - for correlation</span>
                <span class="c"># control:</span>
                <span class="n">spat_comp_pow_minus</span> <span class="o">=</span> <span class="n">spat_comp_powers</span> <span class="o">-</span> <span class="n">spat_comp_power</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">):</span> <span class="c"># DEBUG</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s">&quot;Not all spat_comp_pow_minus, &quot;</span><span class="o">+</span>
                        <span class="s">&quot;</span><span class="si">%d</span><span class="s"> negative values!&quot;</span> <span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">spat_comp_pow_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                
            <span class="k">for</span> <span class="n">fact_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c"># update FB - freq basis</span>
                <span class="n">other_fact_ind_arr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfactors</span><span class="p">)</span>
                <span class="n">other_fact_ind_arr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fact_ind</span><span class="p">)</span>
                <span class="n">other_fact_power</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                            <span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">spat_comp_ind</span><span class="p">,</span>
                            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">],</span>
                            <span class="n">factor_ind</span><span class="o">=</span><span class="n">other_fact_ind_arr</span><span class="p">),</span>
                        <span class="n">eps</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;    Updating frequency basis </span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span>
                            <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="p">)</span>
                    <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                <span class="n">spat_comp_ind</span><span class="p">,</span>
                                <span class="c">#spec_comp_ind=[spec_comp_ind]</span>
                                <span class="p">),</span>
                            <span class="n">eps</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="c">#comp_num = hat_W[spat_comp_ind] / spat_comp_power**(2)</span>
                    <span class="c">#comp_den = 1 / spat_comp_power</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                        
                    <span class="n">FW_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">],</span> <span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    
                    <span class="c"># denominator + correlation penalization</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                            <span class="o">*</span> <span class="n">spat_comp_pow_minus</span> <span class="c">#np.maximum(spat_comp_powers,</span>
                            <span class="c">#           eps)</span>
                            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                    
                    <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other_fact_power</span> <span class="o">*</span> 
                               <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                <span class="n">corrPen</span><span class="p">),</span>
                               <span class="n">FW_H</span><span class="p">))</span>
                    <span class="c"># numerator</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                            <span class="n">spat_comp_power</span>
                            <span class="o">/</span> <span class="n">spat_comp_powers</span>
                            <span class="p">)</span>
                    <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span>
                                <span class="o">/</span> <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                <span class="c"># np.maximum(spat_comp_power**(2), eps)</span>
                                <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                               <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">,</span>
                               <span class="n">FW_H</span><span class="p">))</span>
                    
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                    <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">FW_H</span>
                    
                <span class="c"># update FW - freq weight</span>
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;    Updating frequency weights </span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span>
                            <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="p">)</span>
                    <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                <span class="n">spat_comp_ind</span><span class="p">,</span>
                                <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">]),</span>
                            <span class="n">eps</span><span class="p">)</span>
                        <span class="p">)</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                        
                    <span class="c"># denominator + correlation penalization</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span><span class="c">#-spat_comp_power,</span>
                                         <span class="n">eps</span><span class="p">)</span>
                            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                    <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other_fact_power</span> <span class="o">*</span> 
                                      <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                       <span class="n">corrPen</span><span class="p">),</span>
                                      <span class="c">#other_fact_power /</span>
                                      <span class="c">#spat_comp_power,</span>
                                      <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                        <span class="p">)</span>
                    
                    <span class="c"># numerator</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># </span>
                        <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                            <span class="n">spat_comp_power</span>
                            <span class="o">/</span> <span class="n">spat_comp_powers</span>
                            <span class="p">)</span>
                    <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span>
                                       <span class="o">/</span> <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#np.maximum(spat_comp_power**2,eps)</span>
                                       <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">,</span>
                                      <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                    <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">H</span>
                    
                <span class="c"># update TW - time weights</span>
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;NMF&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Updating time weights </span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span>
                                <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="p">)</span>
                        <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                    <span class="n">spat_comp_ind</span><span class="p">,</span>
                                    <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">]),</span>
                                <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                        
                        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">])</span>
                        
                        <span class="c"># correlation penalization</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span>
                                             <span class="c"># - spat_comp_power,</span>
                                             <span class="n">eps</span><span class="p">)</span>
                                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c">##if self.verbose&gt;2: # DEBUG</span>
                            <span class="c">##    # pedantic :</span>
                            <span class="c">##    print &quot;correlation stuff&quot;,</span>
                            <span class="c">##    print corrPen.mean(), (1./spat_comp_power).mean()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                        
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                            <span class="c"># denominator</span>
                            <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other_fact_power</span> <span class="o">*</span> 
                                              <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                               <span class="n">corrPen</span><span class="p">),</span><span class="c">#other_fact_power / </span>
                                              <span class="c">#spat_comp_power,</span>
                                              <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c"># numerator</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># corrPen &gt; 0:</span>
                                <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                                    <span class="n">spat_comp_power</span>
                                    <span class="o">/</span> <span class="n">spat_comp_powers</span>
                                    <span class="p">)</span>
                            <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                               <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#np.maximum(spat_comp_power**2,</span>
                                               <span class="c">#            eps)</span>
                                               <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                                              <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">,</span>
                                              <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># denominator</span>
                            <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">other_fact_power</span> <span class="o">*</span> 
                                       <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                        <span class="n">corrPen</span><span class="p">),</span> <span class="c">#other_fact_power / </span>
                                       <span class="c">#spat_comp_power</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c"># numerator</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># corrPen &gt; 0:</span>
                                <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                                    <span class="n">spat_comp_power</span>
                                    <span class="o">/</span> <span class="n">spat_comp_powers</span>
                                    <span class="p">)</span>
                            <span class="c">##if self.verbose&gt;5: # DEBUG to discover origin of NaN</span>
                            <span class="c">##    print &quot;corrPen&quot;, corrPen</span>
                            <span class="c">##    print &quot;other_fact_power&quot;, other_fact_power</span>
                            <span class="c">##    print &quot;hat_W&quot;, hat_W[spat_comp_ind]</span>
                            <span class="c">##    print &quot;squared&quot;, np.maximum(spat_comp_power**2,eps)</span>
                                
                            <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">other_fact_power</span> <span class="o">*</span> <span class="p">(</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                        <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                        <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                            
                        <span class="c">##if self.verbose &gt; 8: #DEBUG</span>
                        <span class="c">##    print &quot;comp_num&quot;, comp_num</span>
                        <span class="c">##    print &quot;comp_den&quot;, comp_den</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                            <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                        <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">W</span>
                    <span class="k">elif</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">,</span> <span class="s">&#39;SHMM&#39;</span><span class="p">):</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s">&quot;The GMM/GSMM/HMM still needs to be adapted &quot;</span><span class="o">+</span>
                            <span class="s">&quot;to take into account the different factors. &quot;</span><span class="p">)</span>
                        <span class="n">nbfaccomps</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Updating time weights, &quot;</span><span class="o">+</span>\
                                  <span class="s">&quot;discrete state-based constraints&quot;</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                            <span class="n">errorMsg</span> <span class="o">=</span> <span class="s">&quot;In this implementation, &quot;</span><span class="o">+</span>\
                                       <span class="s">&quot;as in Ozerov&#39;s, non-trivial &quot;</span><span class="o">+</span>\
                                       <span class="s">&quot;time blobs TB is incompatible with &quot;</span><span class="o">+</span>\
                                       <span class="s">&quot;discrete state-based constraints for&quot;</span><span class="o">+</span>\
                                       <span class="s">&quot; the time weights TW&quot;</span>
                            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="s">&#39;TW_all&#39;</span> <span class="ow">in</span> <span class="n">factor</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                                <span class="p">)</span>
                            
                        <span class="k">if</span> <span class="s">&#39;TW_DP_params&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">factor</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">):</span>
                                <span class="c"># prior probabilities</span>
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">)</span> <span class="o">/</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c"># transition probabilities</span>
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">nbfaccomps</span><span class="p">,</span> <span class="n">nbfaccomps</span><span class="p">])</span> <span class="o">/</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">))</span>
                                
                        <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> \
                                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">])</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1.</span>
                            
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Computing the Itakura Saito distance&quot;</span><span class="o">+</span>\
                                  <span class="s">&quot; matrix&quot;</span>
                        <span class="n">ISdivMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbfaccomps</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">compnb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span>
                            
                            <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">):</span>
                                <span class="c"># re-estimating the weights for discrete</span>
                                <span class="c"># state model with the constraint on the</span>
                                <span class="c"># single state presence active.</span>
                                <span class="c"># NB: for GMM and HMM, these weights are</span>
                                <span class="c">#     assumed to be 1</span>
                                <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                            <span class="n">spat_comp_ind</span><span class="p">,</span>
                                            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">],),</span>
                                        <span class="n">eps</span><span class="p">)</span>
                                    <span class="p">)</span>
                                 
                                <span class="c"># NMF like updating for estimating the weight</span>
                                <span class="n">Wbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span>
                                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">][:,</span><span class="n">compnb</span><span class="p">])</span>
                                <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wbasis</span><span class="p">,</span>
                                           <span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
                                    <span class="p">)</span>
                                <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wbasis</span><span class="p">,</span>
                                           <span class="mi">1</span> <span class="o">/</span> <span class="n">spat_comp_power</span><span class="p">)</span>
                                    <span class="p">)</span>
                                
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                                    <span class="n">comp_num</span> <span class="o">/</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                                    <span class="p">)</span> <span class="o">**</span> <span class="n">omega</span>
                                
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span><span class="o">=</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span>
                                
                                <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span>
                                
                            <span class="c"># ratio to compute IS divergence between expected</span>
                            <span class="c"># variance hat_W and the spatial component</span>
                            <span class="c"># with the discrete state restriction</span>
                            <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span><span class="n">spat_comp_ind</span><span class="p">),</span>
                                <span class="n">eps</span><span class="p">)</span>
                                <span class="p">)</span>
                            
                            <span class="n">W_V_ratio</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                <span class="n">spat_comp_power</span><span class="p">)</span>
                            
                            <span class="n">ISdivMatrix</span><span class="p">[</span><span class="n">compnb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W_V_ratio</span>
                                       <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">W_V_ratio</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
                                       <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="p">)</span>
                            
                            <span class="k">del</span> <span class="n">W_V_ratio</span><span class="p">,</span> <span class="n">spat_comp_power</span>
                        
                        <span class="c"># decode the state sequence that minimizes the</span>
                        <span class="c"># track in the IS div matrix, with best</span>
                        <span class="c"># trade-off with the provided TW_DP_params</span>
                        <span class="c"># (temporal constraints)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Decoding the state sequence&quot;</span>
                        <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">):</span>
                            <span class="n">active_state_seq</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                                    <span class="n">ISdivMatrix</span> <span class="o">-</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)),</span>
                                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">del</span> <span class="n">ISdivMatrix</span>
                        <span class="k">elif</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;HMM&#39;</span><span class="p">,</span> <span class="s">&#39;SHMM&#39;</span><span class="p">):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                                <span class="k">print</span> <span class="s">&quot;        Viterbi algorithm to &quot;</span><span class="o">+</span>\
                                      <span class="s">&quot;determine the active state sequence&quot;</span>
                            <span class="n">accumulateVec</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">ISdivMatrix</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">nbfaccomps</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="n">antecedentMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbfaccomps</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                     <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">):</span>
                                <span class="n">tmpMat</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">accumulateVec</span><span class="p">)</span> <span class="o">-</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">))</span>
                                
                                <span class="n">antecedentMat</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">tmpMat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="n">accumulateVec</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="n">tmpMat</span><span class="p">[</span><span class="n">antecedentMat</span><span class="p">[:,</span><span class="n">n</span><span class="p">],</span>
                                           <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">)]</span> <span class="o">+</span> 
                                    <span class="n">ISdivMatrix</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="c"># to avoid overflow?</span>
                                <span class="n">accumulateVec</span> <span class="o">-=</span> <span class="n">accumulateVec</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                            
                            <span class="k">del</span> <span class="n">tmpMat</span>
                            
                            <span class="n">active_state_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">,</span>
                                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                            <span class="n">active_state_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">accumulateVec</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">framenb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                <span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">antecedentMat</span><span class="p">[</span><span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="p">],</span>
                                                  <span class="n">framenb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="p">)</span>
                            
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                <span class="s">&quot;No implementation for time constraint other &quot;</span><span class="o">+</span>
                                <span class="s">&quot;than GMM, GSMM, HMM and SHMM&quot;</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Update Time Weights&quot;</span>
                            
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="k">for</span> <span class="n">framenb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="p">],</span><span class="n">framenb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][</span><span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="p">],</span>
                                                 <span class="n">framenb</span><span class="p">]</span>
                                <span class="p">)</span>
                            
                        <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Updating the transition probabilities&quot;</span>
                            <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">compnb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">active_state_seq</span><span class="o">==</span><span class="n">compnb</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span>
                                        <span class="p">)</span>
                            <span class="k">elif</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;HMM&#39;</span><span class="p">,</span> <span class="s">&#39;SHMM&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">prevstate</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                                    <span class="n">upd_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                        <span class="n">active_state_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">prevstate</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">upd_den</span><span class="p">:</span>
                                        <span class="k">for</span> <span class="n">nextstate</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                                            <span class="n">upd_num</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                                <span class="p">(</span><span class="n">active_state_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span>
                                                 <span class="n">prevstate</span><span class="p">)</span> <span class="o">*</span>
                                                <span class="p">(</span><span class="n">active_state_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span>
                                                 <span class="n">nextstate</span><span class="p">))</span>
                                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">][</span><span class="n">prevstate</span><span class="p">,</span>
                                                                   <span class="n">nextstate</span><span class="p">]</span><span class="o">=</span><span class="p">(</span>
                                                <span class="n">upd_num</span> <span class="o">/</span> <span class="n">upd_den</span>
                                                <span class="p">)</span> <span class="c"># TODO: check this part</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                    <span class="s">&quot;Required time constraints not &quot;</span><span class="o">+</span>
                                    <span class="s">&quot;implemented.&quot;</span><span class="p">)</span>
                        
                <span class="c"># update TB = time basis</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;    Updating Time basis&quot;</span>
                    <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                <span class="n">spat_comp_ind</span><span class="p">,</span>
                                <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">],),</span>
                            <span class="n">eps</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">W</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]),</span>
                               <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="c"># denominator + correlation penalization</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span><span class="c"># - spat_comp_power,</span>
                                         <span class="n">eps</span><span class="p">)</span>
                            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="c">##if self.verbose&gt;2:#DEBUG</span>
                        <span class="c">##    # pedantic :</span>
                        <span class="c">##    print corrPen.mean(), (1./spat_comp_power).mean()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                    <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">other_fact_power</span> <span class="o">*</span> 
                               <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                <span class="n">corrPen</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="c"># numerator</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># corrPen &gt; 0:</span>
                        <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                            <span class="n">spat_comp_power</span>
                            <span class="o">/</span> <span class="n">spat_comp_powers</span>
                            <span class="p">)</span>
                    <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span>
                                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                                <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                               <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                    <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">W</span>
    </div>
<div class="viewcode-block" id="FASST.renormalize_parameters"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.renormalize_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">renormalize_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;renormalize_parameters</span>
<span class="sd">        </span>
<span class="sd">        Re-normalize the components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    re-normalizing components&quot;</span>
        <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;         normalizing spatial components...&quot;</span>
        <span class="c"># renormalize spatial components</span>
        <span class="n">Kspat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)</span>
        <span class="n">spat_global_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Kspat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spat_global_energy</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">spat_global_energy</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">])</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;spat_global_energy&quot;</span><span class="p">,</span> <span class="n">spat_global_energy</span>
        
        <span class="c"># renormalize spectral components</span>
        <span class="n">Kspec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">global_energy</span> <span class="o">=</span> <span class="n">spat_global_energy</span><span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]]</span>
            
            <span class="n">nbfactors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">])</span>
            
            <span class="k">for</span> <span class="n">fact_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">global_energy</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c">#.mean(axis=0)</span>
                <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">):</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="c"># Only testing this: in order to avoid</span>
                    <span class="c"># big crash, if for one factor, everything in TW</span>
                    <span class="c"># turns out to get 0, then &quot;restart&quot; it with random</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1e3</span> <span class="o">*</span> <span class="n">eps</span> <span class="c"># so it s not too small</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    renorm: reinitialized TW for spec&quot;</span><span class="p">,</span>
                            <span class="k">print</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="s">&quot;factor&quot;</span><span class="p">,</span> <span class="n">fact_ind</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">w</span>
                        
                    <span class="n">global_energy</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">fact_ind</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nbfactors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">global_energy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s">&quot;Temporal discrete state mngmt not done yet. &quot;</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="FASST.setComponentParameter"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.setComponentParameter">[docs]</a>    <span class="k">def</span> <span class="nf">setComponentParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">partLabel</span><span class="o">=</span><span class="s">&#39;FB&#39;</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="s">&#39;free&#39;</span><span class="p">,</span>
                              <span class="n">keepDimensions</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper function to set a</span>
<span class="sd">        self.spec_comp[spec_ind][&#39;factor&#39;][fact_ind][partLabel] to</span>
<span class="sd">        the given value.</span>
<span class="sd">        </span>
<span class="sd">        TODO 20130522 finish this function to make it general purpose...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">###### DEBUG #####</span>
        <span class="k">print</span> <span class="s">&quot;NOT IMPLEMENTED YET, PLEASE SET THE COMPONENTS DIRECTLY&quot;</span>
        <span class="k">pass</span>
        <span class="c">###### DEBUG #####</span>
        <span class="k">if</span> <span class="n">keepDimenstions</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">newValue</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="n">partLabel</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;the provided value does not have the correct&quot;</span><span class="o">+</span>
                                 <span class="s">&quot; size:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">newValue</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span>
                                 <span class="s">&quot; instead of &quot;</span><span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="n">partLabel</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># nightmare of error checking for sizes... </span>
            <span class="k">if</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;FB&#39;</span><span class="p">:</span>
                <span class="n">newShape</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">oldShape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span>
                    <span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">newShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;FB: cannot change dimension of &quot;</span><span class="o">+</span>
                                     <span class="s">&quot;signal representation.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">oldShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;    Changing the Freq Weights for FB:&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
            <span class="k">elif</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;FW&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;TW&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;TB&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No such thing as &quot;</span><span class="o">+</span>
                                 <span class="n">partLabel</span><span class="o">+</span>
                                 <span class="s">&quot; in components!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span>
            <span class="n">partLabel</span><span class="o">+</span><span class="s">&#39;_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span>
                </div>
<div class="viewcode-block" id="FASST.initialize_all_spec_comps_with_NMF"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.initialize_all_spec_comps_with_NMF">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_all_spec_comps_with_NMF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                           <span class="n">sameInitAll</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes an NMF on the one-channel mix (averaging diagonal</span>
<span class="sd">        of self.Cx, which are the power spectra of the corresponding</span>
<span class="sd">        channel)</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            C_x \\approx W H</span>
<span class="sd">        </span>
<span class="sd">        then, for all spec_comp in self.spec_comps, we set::</span>
<span class="sd">        </span>
<span class="sd">            spec_comp[&#39;FB&#39;] = W</span>
<span class="sd">            spec_comp[&#39;TW&#39;] = H</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sameInitAll</span><span class="p">:</span>
            <span class="c"># initialize the components with the same parameters</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_all_spec_comps_with_NMF_same</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># initialize the components with individual params,</span>
            <span class="c"># in particular, initializing the NMF with the available</span>
            <span class="c"># components (but only with factor 0)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_all_spec_comps_with_NMF_indiv</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FASST.initialize_all_spec_comps_with_NMF_indiv"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.initialize_all_spec_comps_with_NMF_indiv">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_all_spec_comps_with_NMF_indiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                 <span class="n">updateFreqBasis</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                 <span class="n">updateTimeWeight</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize the spectral components with an NMF decomposition,</span>
<span class="sd">        with individual decomposition of the monophonic signal TF</span>
<span class="sd">        representation.</span>

<span class="sd">        TODO make keepFBind and keepTWind, in order to provide</span>
<span class="sd">        finer control on which indices are updated. Also requires</span>
<span class="sd">        a modified NMF decomposition function.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># list of the sizes of the 0th factors, of all components</span>
        <span class="n">nbSpecComps</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">totalNMFComps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">)</span>
        
        <span class="c"># initializing the NMF FreqBasis (FB) and TimeWeight (TW)</span>
        <span class="c"># with the corresponding quantities in self.spec_comps:</span>
        <span class="n">FBinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="n">totalNMFComps</span><span class="p">])</span>
        <span class="n">TWinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">totalNMFComps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ind_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">[:</span><span class="n">spec_ind</span><span class="p">])</span>
            <span class="n">ind_stop</span> <span class="o">=</span> <span class="n">ind_start</span> <span class="o">+</span> <span class="n">nbSpecComps</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span>
            <span class="n">FBinit</span><span class="p">[:,</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">])</span>
            <span class="n">TWinit</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">])</span>
        
        <span class="c"># computing the monaural signal representation</span>
        <span class="c">#     summing the contributions over all the channels:</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
            <span class="c"># stored an &quot;efficient&quot; way, so index &quot;complicated&quot;:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Cx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            
        <span class="n">Cx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        
        <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">NMF_decomp_init</span><span class="p">(</span><span class="n">SX</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span> <span class="n">nbComps</span><span class="o">=</span><span class="n">totalNMFComps</span><span class="p">,</span>
                               <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">Winit</span><span class="o">=</span><span class="n">FBinit</span><span class="p">,</span> <span class="n">Hinit</span><span class="o">=</span><span class="n">TWinit</span><span class="p">,</span>
                               <span class="n">updateW</span><span class="o">=</span><span class="n">updateFreqBasis</span><span class="p">,</span>
                               <span class="n">updateH</span><span class="o">=</span><span class="n">updateTimeWeight</span><span class="p">)</span>
        
        <span class="c"># copy the result in the corresponding spec_comps:</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ind_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">[:</span><span class="n">spec_ind</span><span class="p">])</span>
            <span class="n">ind_stop</span> <span class="o">=</span> <span class="n">ind_start</span> <span class="o">+</span> <span class="n">nbSpecComps</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">updateFreqBasis</span><span class="p">:</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="n">W</span><span class="p">[:,</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">],</span>
                        <span class="n">eps</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">updateTimeWeight</span><span class="p">:</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">],</span><span class="n">eps</span><span class="p">))</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="FASST.initialize_all_spec_comps_with_NMF_same"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.initialize_all_spec_comps_with_NMF_same">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_all_spec_comps_with_NMF_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize all the components with the same amplitude and spectral</span>
<span class="sd">        matrices `W` and `H`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span>
                       <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s">&quot;NMF init not implemented for multi factor models.&quot;</span><span class="p">)</span>
        
        <span class="n">nbSpecComps</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">nbComps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">)</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="c"># computing the signal representation</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
            <span class="c"># stored an &quot;efficient&quot; way, so index &quot;complicated&quot;:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Cx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            
        <span class="n">Cx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        
        <span class="c"># computing NMF of Cx:</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">NMF_decomposition</span><span class="p">(</span><span class="n">SX</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                                 <span class="n">nbComps</span><span class="o">=</span><span class="n">nbComps</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>
        
        <span class="c"># reordering so that most energy in first components</span>
        <span class="n">Hsum</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">indexSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">Hsum</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">indexSort</span><span class="p">]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">indexSort</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ncomp</span> <span class="o">=</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ncomp</span><span class="p">]</span>
            <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[:</span><span class="n">ncomp</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="FASST.initializeConvParams"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.FASST.initializeConvParams">[docs]</a>    <span class="k">def</span> <span class="nf">initializeConvParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initMethod</span><span class="o">=</span><span class="s">&#39;demix&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;setting the spatial parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Spatial component </span><span class="si">%d</span><span class="s"> &quot;</span><span class="o">%</span><span class="n">spat_ind</span><span class="o">+</span>
                              <span class="s">&quot;already not instantaneous, overwriting...&quot;</span><span class="p">)</span>
            
            <span class="c"># spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
            <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;conv&#39;</span>
            <span class="c"># spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
        
        <span class="k">if</span> <span class="n">initMethod</span> <span class="o">==</span> <span class="s">&#39;demix&#39;</span><span class="p">:</span>
            <span class="n">maxclusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">))</span>
            <span class="n">neighbours</span> <span class="o">=</span> <span class="mi">15</span>
            
            <span class="c"># default for demix to work best: #FIXME!!!</span>
            <span class="n">wlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span><span class="c"># 20482048</span>
            <span class="n">hopsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span><span class="c">#1024 </span>
            
            <span class="n">demixInst</span> <span class="o">=</span> <span class="n">demix</span><span class="o">.</span><span class="n">DEMIX</span><span class="p">(</span>
                <span class="n">audio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">nsources</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">),</span> <span class="c"># spatial comps for demix</span>
                <span class="n">wlen</span><span class="o">=</span><span class="n">wlen</span><span class="p">,</span>
                <span class="n">hopsize</span><span class="o">=</span><span class="n">hopsize</span><span class="p">,</span>
                <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbours</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">maxclusters</span><span class="o">=</span><span class="n">maxclusters</span><span class="p">)</span>
            
            <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_pcafeatures</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_parameters</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">init_subpts_set</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_clusters</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">refine_clusters</span><span class="p">()</span>
            
            <span class="c"># mixing parameters from DEMIX estimation:</span>
            <span class="c">#     results in an nsrc x nfreqs x nc array</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">demixInst</span><span class="o">.</span><span class="n">steeringVectorsFromCentroids</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">demixInst</span>
        <span class="k">elif</span> <span class="s">&#39;rand&#39;</span> <span class="ow">in</span> <span class="n">initMethod</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                <span class="n">nc</span><span class="p">,)</span>
                <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                       <span class="n">nc</span><span class="p">,)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Init method not implemented.&quot;</span><span class="p">)</span>
            
        <span class="c"># filling the spatial components:</span>
        <span class="k">for</span> <span class="n">nspat</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">spat_comp_param_inst</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
            <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">],</span>
                                            <span class="n">nc</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">]):</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>
    </div></div>
<div class="viewcode-block" id="MultiChanNMFInst_FASST"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.MultiChanNMFInst_FASST">[docs]</a><span class="k">class</span> <span class="nc">MultiChanNMFInst_FASST</span><span class="p">(</span><span class="n">FASST</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MultiChanNMFInst_FASST</span>
<span class="sd">    </span>
<span class="sd">    sub-classes FASST</span>
<span class="sd">    </span>
<span class="sd">    This class implements the Multi-channel Non-Negative Matrix Factorisation</span>
<span class="sd">    (NMF) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbNMFComps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DESCRIPTION</span>
<span class="sd">        -----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        ARGUMENTS</span>
<span class="sd">        ---------</span>
<span class="sd">        </span>
<span class="sd">        nbComps (int)</span>
<span class="sd">            The number of (spatial) components in FASST framework.</span>
<span class="sd">            </span>
<span class="sd">        nbNMFComps (int)</span>
<span class="sd">            The number of NMF components in each spatial component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiChanNMFInst_FASST</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_transf_Cx</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">=</span> <span class="n">nbComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span> <span class="o">=</span> <span class="n">nbNMFComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">spatial_rank</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_structures</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_initialize_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c">#, nbComps, nbNMFComps, spatial_rank):</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
            <span class="c"># initialize the spatial component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;time_dep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;indep&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;inst&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># spreading the sources evenly for init on stereo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)]))</span>
            
            <span class="c"># initialize single factor spectral component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
<div class="viewcode-block" id="MultiChanNMFInst_FASST.setSpecCompFB"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.MultiChanNMFInst_FASST.setSpecCompFB">[docs]</a>    <span class="k">def</span> <span class="nf">setSpecCompFB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compNb</span><span class="p">,</span> <span class="n">FB</span><span class="p">,</span> <span class="n">FB_frdm_prior</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SetSpecCompFB</span>
<span class="sd">        </span>
<span class="sd">        sets the spectral component&#39;s frequency basis.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speccomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">compNb</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span> <span class="o">!=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Size of provided FB is not consistent&quot;</span><span class="o">+</span>
                                 <span class="s">&quot; with inner attributes&quot;</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">FB</span><span class="p">)</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FB_frdm_prior</span>
</div></div>
<div class="viewcode-block" id="MultiChanNMFConv"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.MultiChanNMFConv">[docs]</a><span class="k">class</span> <span class="nc">MultiChanNMFConv</span><span class="p">(</span><span class="n">MultiChanNMFInst_FASST</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Takes the multichannel NMF instantaneous class, and makes it</span>
<span class="sd">    convolutive!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbNMFComps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiChanNMFConv</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span>
                                               <span class="n">nbComps</span><span class="o">=</span><span class="n">nbComps</span><span class="p">,</span>
                                               <span class="n">nbNMFComps</span><span class="o">=</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                               <span class="n">spatial_rank</span><span class="o">=</span><span class="n">spatial_rank</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># self.makeItConvolutive()</span>
        <span class="c"># DIY: upgrade to convolutive after a few instantaneous, maybe? </span>
        
    <span class="k">def</span> <span class="nf">makeItConvolutive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">nspat</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Spatial component </span><span class="si">%d</span><span class="s"> &quot;</span><span class="o">%</span><span class="n">spat_ind</span><span class="o">+</span>
                              <span class="s">&quot;already not instantaneous, skipping...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;conv&#39;</span>
                <span class="c"># spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
                <span class="n">spat_comp_param_inst</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">],</span>
                                                <span class="n">nc</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">][:,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">spat_comp_param_inst</span><span class="o">.</span><span class="n">T</span>
</div>
<span class="k">class</span> <span class="nc">MultiChanHMM</span><span class="p">(</span><span class="n">MultiChanNMFConv</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbNMFComps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiChanHMM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span>
                                               <span class="n">nbComps</span><span class="o">=</span><span class="n">nbComps</span><span class="p">,</span>
                                               <span class="n">nbNMFComps</span><span class="o">=</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                               <span class="n">spatial_rank</span><span class="o">=</span><span class="n">spatial_rank</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">makeItHMM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns the required parameters into HMM time constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">fac_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;HMM&#39;</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
    
    <span class="k">def</span> <span class="nf">makeItSHMM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns the required parameters into SHMM time constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">fac_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">nbfaccomps</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;SHMM&#39;</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span> <span class="n">nbfaccomps</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
                <span class="c"># factor[&#39;TW_DP_frdm_prior&#39;] = &#39;free&#39;</span>
        
<div class="viewcode-block" id="multiChanSourceF0Filter"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter">[docs]</a><span class="k">class</span> <span class="nc">multiChanSourceF0Filter</span><span class="p">(</span><span class="n">FASST</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;multi channel source/filter model</span>
<span class="sd">    nbcomps components, nbcomps-1 SF models, 1 residual component</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                 <span class="n">nbNMFResComps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">nbFilterComps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> 
                 <span class="n">nbFilterWeigs</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,],</span> 
                 <span class="n">minF0</span><span class="o">=</span><span class="mi">39</span><span class="p">,</span> <span class="n">maxF0</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">minF0search</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">maxF0search</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
                 <span class="n">stepnoteF0</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">chirpPerF0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">sparsity</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DESCRIPTION</span>
<span class="sd">        -----------</span>
<span class="sd">        __init__(self, audio,</span>
<span class="sd">                 nbComps=3, ## nb of components</span>
<span class="sd">                 nbNMFResComps=3, ## nb of residual components</span>
<span class="sd">                 nbFilterComps=20, ## nb of filter components</span>
<span class="sd">                 nbFilterWeigs=4, ## nb of filter components</span>
<span class="sd">                 minF0=80, maxF0=800, ## range for comb spectra</span>
<span class="sd">                 stepnoteF0=4, chirpPerF0=1, </span>
<span class="sd">                 spatial_rank=1,</span>
<span class="sd">                 sparsity=None,</span>
<span class="sd">                 **kwargs)</span>
<span class="sd">        </span>
<span class="sd">        ARGUMENTS</span>
<span class="sd">        ---------</span>
<span class="sd">        </span>
<span class="sd">        nbComps (int)</span>
<span class="sd">            The number of (spatial) components in FASST framework.</span>
<span class="sd">            </span>
<span class="sd">        nbNMFComps (int)</span>
<span class="sd">            The number of NMF components in each spatial component.</span>
<span class="sd">            </span>
<span class="sd">        sparsity (list of size 1 or nbComps)</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">multiChanSourceF0Filter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_transf_Cx</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;minF0&#39;</span><span class="p">:</span> <span class="n">minF0</span><span class="p">,</span>
                             <span class="s">&#39;maxF0&#39;</span><span class="p">:</span> <span class="n">maxF0</span><span class="p">,</span>
                             <span class="s">&#39;stepnoteF0&#39;</span><span class="p">:</span> <span class="n">stepnoteF0</span><span class="p">,</span>
                             <span class="s">&#39;chirpPerF0&#39;</span><span class="p">:</span> <span class="n">chirpPerF0</span><span class="p">,</span>
                             <span class="s">&#39;minF0search&#39;</span><span class="p">:</span> <span class="n">minF0search</span><span class="p">,</span>
                             <span class="s">&#39;maxF0search&#39;</span><span class="p">:</span> <span class="n">maxF0search</span><span class="p">,}</span>
                             <span class="c"># __c quoi ca...__ &#39;chirpPerF02072&#39;: chirpPerF0}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">=</span> <span class="n">nbComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span> <span class="o">=</span> <span class="n">nbNMFResComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span> <span class="o">=</span> <span class="n">nbFilterComps</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbFilterWeigs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span> <span class="o">=</span> <span class="n">nbFilterWeigs</span>
            
        <span class="c"># initialize the spatial_ranks, reformating here.</span>
        <span class="c"># 20130611 TODO check that it does not break too much everywhere!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">spatial_rank</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span>
        
        <span class="c"># the source dictionary is shared among all the components,</span>
        <span class="c"># so storing it one for all:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F0Table</span><span class="p">,</span> <span class="n">WF0</span><span class="p">,</span> <span class="n">trfoBis</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c">#generate_WF0_chirped(minF0, maxF0,</span>
            <span class="c">#                     Fs=self.audioObject.samplerate,</span>
            <span class="c">#                     Nfft=self.sig_repr_params[&#39;fsize&#39;],</span>
            <span class="c">#                     stepNotes=stepnoteF0,</span>
            <span class="c">#                     lengthWindow=self.sig_repr_params[&#39;wlen&#39;],</span>
            <span class="c">#                     Ot=0.5,</span>
            <span class="c">#                     perF0=chirpPerF0,</span>
            <span class="c">#                     depthChirpInSemiTone=0.5,</span>
            <span class="c">#                     loadWF0=True,</span>
            <span class="c">#                     analysisWindow=&#39;hanning&#39;)</span>
            <span class="n">SLS</span><span class="o">.</span><span class="n">slf</span><span class="o">.</span><span class="n">generate_WF0_TR_chirped</span><span class="p">(</span>
                <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="p">,</span>
                <span class="n">minF0</span><span class="o">=</span><span class="n">minF0</span><span class="p">,</span> <span class="n">maxF0</span><span class="o">=</span><span class="n">maxF0</span><span class="p">,</span>
                <span class="n">stepNotes</span><span class="o">=</span><span class="n">stepnoteF0</span><span class="p">,</span>
                <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">perF0</span><span class="o">=</span><span class="n">chirpPerF0</span><span class="p">,</span> 
                <span class="n">depthChirpInSemiTone</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">loadWF0</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,)</span>
            <span class="p">)</span>
        
        <span class="c"># removing patterns in low energy bins - setting to eps:</span>
        <span class="k">for</span> <span class="n">nwf0comp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WF0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> 
            <span class="n">indLowEnergy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">WF0</span><span class="p">[:,</span><span class="n">nwf0comp</span><span class="p">]</span><span class="o">&lt;</span><span class="n">WF0</span><span class="p">[:,</span><span class="n">nwf0comp</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">)</span>
            <span class="n">WF0</span><span class="p">[</span><span class="n">indLowEnergy</span><span class="p">,</span> <span class="n">nwf0comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">WF0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">))]))</span>
            <span class="p">)</span>
        <span class="k">del</span> <span class="n">WF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span><span class="p">)</span>
        <span class="c"># ... and the same for the filter part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterFreqComps</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">generateHannBasis</span><span class="p">(</span>
                <span class="n">numberFrequencyBins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                <span class="n">sizeOfFourier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">,</span>
                <span class="n">frequencyScale</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span>
                <span class="n">numberOfBasis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span> <span class="o">=</span> <span class="n">sparsity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_structures</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_initialize_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">sparsity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># initialize the spatial component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;time_dep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;indep&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;inst&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># spreading the sources evenly for init on stereo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)]))</span>
            
            <span class="c"># initialize source factor spectral component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqWeights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
            
            <span class="c"># initialize filter factor spectral components</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filterFreqComps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
            
        <span class="c"># residual component:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resSpatialRank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c">#2</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c"># initialize the spatial component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;time_dep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;indep&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;inst&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resSpatialRank</span><span class="p">)</span>
        <span class="c"># 20120920 trying no initialization for residual:</span>
        <span class="c">##if nc == 2: # spreading the sources evenly for init on stereo</span>
        <span class="c">##    self.spat_comps[j][&#39;params&#39;] = (</span>
        <span class="c">##        np.array([np.sin((j+1) * np.pi / (2.*(self.nbComps + 1))) +</span>
        <span class="c">##                np.random.randn(self.resSpatialRank)*np.sqrt(0.01),</span>
        <span class="c">##                np.cos((j+1) * np.pi / (2.*(self.nbComps + 1))) +</span>
        <span class="c">##                np.random.randn(self.resSpatialRank)*np.sqrt(0.01)]))</span>
            
        <span class="c"># initialize single factor spectral component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span><span class="p">))</span> <span class="o">+</span>
            <span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
            <span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
        
        <span class="k">if</span> <span class="n">sparsity</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
            <span class="c"># sparsity induces a &quot;sparse&quot; activation of</span>
            <span class="c"># self.spec_comps[j][&#39;factor&#39;][0][&#39;TW&#39;], that is,</span>
            <span class="c"># the time weights for the source part.</span>
            <span class="c"># This is implemented as in:</span>
            <span class="c"># Durrieu, J.-L. &amp; Thiran, J.-P.</span>
            <span class="c">#    Sparse Non-Negative Decomposition Of Speech Power Spectra For</span>
            <span class="c">#    Formant Tracking</span>
            <span class="c"># in proc. of the IEEE International Conference on Acoustics,</span>
            <span class="c"># Speech and Signal Processing, Pragues, Czech Republic, 2011.</span>
            <span class="c">#</span>
            <span class="c"># This means that at each GEM iteration, the TW coefficients</span>
            <span class="c"># are further shrinked down to be concentrating around a</span>
            <span class="c"># single component (a single F0 in SF model)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
<div class="viewcode-block" id="multiChanSourceF0Filter.initSpecCompsWithLabelAndFiles"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.initSpecCompsWithLabelAndFiles">[docs]</a>    <span class="k">def</span> <span class="nf">initSpecCompsWithLabelAndFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instrus</span><span class="o">=</span><span class="p">[],</span> <span class="n">instru2modelfile</span><span class="o">=</span><span class="p">{},</span>
                                       <span class="n">freqBasisAdaptive</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the spectral components with the instrument labels as</span>
<span class="sd">        well as with the components stored in the provided dictionary in</span>
<span class="sd">        `instru2modelfile`</span>
<span class="sd">        </span>
<span class="sd">        `instrus` is a list with labels:</span>
<span class="sd">            `&#39;SourceFilter&#39;`: keep the intialized source filter model</span>
<span class="sd">            `&#39;Free_&lt;nb_comp&gt;&#39;`: initialize the model with an adaptable</span>
<span class="sd">                spectral component using `nb_comp` elements in the NMF</span>
<span class="sd">                frequency basis</span>
<span class="sd">            `&lt;key_in_instru2modelfile&gt;`: initialize with the :py:class:GSMM</span>
<span class="sd">                available and stored in the archive npz with filename</span>
<span class="sd">                `instru2modelfile[key_in_instru2modelfile]`</span>
<span class="sd">                </span>
<span class="sd">        NB: needs the gmm-gsmm module to be installed and in the pythonpath</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instrumentNames</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instrus</span><span class="p">):</span>
            <span class="n">instrumentNames</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s">&#39;SourceFilter&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">print</span> <span class="s">&quot;    Source&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;left as general Source-Filter model.&quot;</span>
            <span class="k">elif</span> <span class="s">&#39;Free&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span> <span class="c"># assumes Free_nbNMFComps</span>
                <span class="n">nbNMFComps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">print</span> <span class="s">&quot;    Source&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;set as free NMF source.&quot;</span>
                <span class="c"># initialize single factor spectral component</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                  <span class="n">nbNMFComps</span><span class="p">))</span> <span class="o">+</span>
                    <span class="mf">0.25</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nbNMFComps</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                    <span class="mf">0.25</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
                <span class="c"># sparsity stuff</span>
                <span class="n">sparsity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span>
                <span class="k">if</span> <span class="n">sparsity</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c">#if i != &#39;SourceFilter&#39;:</span>
                <span class="k">print</span> <span class="s">&quot;    Source&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="n">i</span>
                <span class="n">modelfile</span> <span class="o">=</span> <span class="n">instru2modelfile</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">struc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">modelfile</span><span class="p">)</span>
                <span class="n">gsmm</span> <span class="o">=</span> <span class="n">struc</span><span class="p">[</span><span class="s">&#39;gsmm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="c"># Keeping only spectra that are not flat:</span>
                <span class="n">decisionSpectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">gsmm</span><span class="o">.</span><span class="n">sigw</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c"># keeping only the spectra with enough weight:</span>
                <span class="c">#     hard decision, remove all spectra with w == min(w)</span>
                <span class="c"># decisionOnWeight = np.where(gsmm.w!=gsmm.w.min())[0]</span>
                <span class="c">#     harder decision: remove all with w under a threshold:</span>
                <span class="n">decisionOnWeight</span> <span class="o">=</span> <span class="p">(</span><span class="n">gsmm</span><span class="o">.</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">gsmm</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">)</span>
                
                <span class="n">keepIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">decisionSpectra</span><span class="o">+</span><span class="n">decisionOnWeight</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="n">FB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">gsmm</span><span class="o">.</span><span class="n">sigw</span><span class="p">[</span><span class="n">keepIndex</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="c">#self.setSpecCompFB(compNb=n, FB=FB, FB_frdm_prior=&#39;fixed&#39;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setSpecCompFB</span><span class="p">(</span><span class="n">compNb</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">FB</span><span class="o">=</span><span class="n">FB</span><span class="p">,</span>
                                   <span class="n">FB_frdm_prior</span><span class="o">=</span><span class="n">freqBasisAdaptive</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">struc</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">instrumentNames</span>
        </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.setSpecCompFB"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.setSpecCompFB">[docs]</a>    <span class="k">def</span> <span class="nf">setSpecCompFB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compNb</span><span class="p">,</span> <span class="n">FB</span><span class="p">,</span> <span class="n">FB_frdm_prior</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;SetSpecCompFB</span>
<span class="sd">        </span>
<span class="sd">        sets the spectral component&#39;s frequency basis.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speccomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">compNb</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span> <span class="o">!=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Size of provided FB is not consistent&quot;</span><span class="o">+</span>
                                 <span class="s">&quot; with inner attributes&quot;</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">FB</span><span class="p">)</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FB_frdm_prior</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.initializeFreeMats"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.initializeFreeMats">[docs]</a>    <span class="k">def</span> <span class="nf">initializeFreeMats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize free matrices, with NMF decomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># we initialize the matrices with NMF decomposition using the</span>
        <span class="c"># source matrix as basis W, the residual is left uninitialized</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="c"># computing the signal representation</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
            <span class="c"># stored an &quot;efficient&quot; way, so index &quot;complicated&quot;:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Cx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        
        <span class="n">Cx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        
        <span class="c"># computing NMF of Cx:</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">NMF_decomp_init</span><span class="p">(</span><span class="n">SX</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span>
                               <span class="n">Winit</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]),</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">nbComps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span><span class="p">,</span>
                               <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
                               <span class="n">updateW</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">updateH</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="p">)</span>
        <span class="c">##W, H, WFilt, HFilt = SFNMF_decomp_init(</span>
        <span class="c">##    SX=Cx,</span>
        <span class="c">##    nbComps=self.nbSourceComps,</span>
        <span class="c">##    nbFiltComps=self.nbFilterComps,</span>
        <span class="c">##    niter=niter, verbose=self.verbose,</span>
        <span class="c">##    Winit=,</span>
        <span class="c">##    Hinit=None,</span>
        <span class="c">##    WFiltInit=self.filterFreqComps,</span>
        <span class="c">##    HFiltInit=None,</span>
        <span class="c">##    updateW=False, updateH=True,</span>
        <span class="c">##    updateWFilt=False, updateHFilt=True)</span>
        
        <span class="k">for</span> <span class="n">ncomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">spec_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">ncomp</span><span class="p">]</span>
            <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.makeItConvolutive"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.makeItConvolutive">[docs]</a>    <span class="k">def</span> <span class="nf">makeItConvolutive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes the spatial parameters and sets them to a convolutive</span>
<span class="sd">        mixture, in case the parameter has not yet been changed to</span>
<span class="sd">        &#39;conv&#39; mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">nspat</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Spatial component </span><span class="si">%d</span><span class="s"> &quot;</span><span class="o">%</span><span class="n">spat_ind</span><span class="o">+</span>
                              <span class="s">&quot;already not instantaneous, skipping...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;conv&#39;</span>
                <span class="c"># spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
                <span class="n">spat_comp_param_inst</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">],</span>
                                                <span class="n">nc</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">][:,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">spat_comp_param_inst</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                    
<span class="c">##    def initializeConvParams(self, initMethod=&#39;demix&#39;):</span>
<span class="c">##        &quot;&quot;&quot;setting the spatial parameters</span>
<span class="c">##        &quot;&quot;&quot;</span>
<span class="c">##        nc = self.audioObject.channels</span>
<span class="c">##        for spat_ind, spat_comp in self.spat_comps.items():</span>
<span class="c">##            if spat_comp[&#39;mix_type&#39;] != &#39;inst&#39;:</span>
<span class="c">##                warnings.warn(&quot;Spatial component %d &quot;%spat_ind+</span>
<span class="c">##                              &quot;already not instantaneous, overwriting...&quot;)</span>
            
<span class="c">##            # spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
<span class="c">##            spat_comp[&#39;mix_type&#39;] = &#39;conv&#39;</span>
<span class="c">##            # spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
        
<span class="c">##        if initMethod == &#39;demix&#39;:</span>
<span class="c">##            maxclusters = max(40, 10 * len(self.spat_comps))</span>
<span class="c">##            neighbours = 15</span>
            
<span class="c">##            # default for demix to work best: #FIXME!!!</span>
<span class="c">##            wlen = self.demixParams[&#39;wlen&#39;]# 2048</span>
<span class="c">##            hopsize = self.demixParams[&#39;hopsize&#39;]</span>
            
<span class="c">##            demixInst = demix.DEMIX(</span>
<span class="c">##                audio=self.audioObject.filename,</span>
<span class="c">##                nsources=len(self.spat_comps), # spatial comps for demix</span>
<span class="c">##                #wlen=wlen,</span>
<span class="c">##                #hopsize=hopsize,</span>
<span class="c">##                #neighbors=neighbours,</span>
<span class="c">##                verbose=self.verbose,</span>
<span class="c">##                maxclusters=maxclusters,</span>
<span class="c">##                **self.demixParams)</span>
            
<span class="c">##            demixInst.comp_pcafeatures()</span>
<span class="c">##            demixInst.comp_parameters()</span>
<span class="c">##            demixInst.init_subpts_set()</span>
<span class="c">##            demixInst.comp_clusters()</span>
<span class="c">##            demixInst.refine_clusters()</span>
            
<span class="c">##            # mixing parameters from DEMIX estimation:</span>
<span class="c">##            #     results in an nsrc x nfreqs x nc array</span>
<span class="c">##            A = demixInst.steeringVectorsFromCentroids()</span>
<span class="c">##            del demixInst</span>
<span class="c">##        elif &#39;rand&#39; in initMethod:</span>
<span class="c">##            A = (</span>
<span class="c">##                np.random.randn(self.rank,</span>
<span class="c">##                                self.nbFreqsSigRepr,</span>
<span class="c">##                                nc,)</span>
<span class="c">##                + 1j * np.random.randn(self.rank,</span>
<span class="c">##                                self.nbFreqsSigRepr,</span>
<span class="c">##                                nc,)</span>
<span class="c">##                )</span>
<span class="c">##        else:</span>
<span class="c">##            raise ValueError(&quot;Init method not implemented.&quot;)</span>
            
<span class="c">##        # filling the spatial components:</span>
<span class="c">##        for spat_ind, spat_comp in self.spat_comps.items():</span>
<span class="c">##            spat_comp_param_inst = spat_comp[&#39;params&#39;]</span>
<span class="c">##            spat_comp[&#39;params&#39;] = np.zeros([self.rank,</span>
<span class="c">##                                            nc,</span>
<span class="c">##                                            self.nbFreqsSigRepr],</span>
<span class="c">##                                           dtype=np.complex)</span>
<span class="c">##            for r in range(self.rank):</span>
<span class="c">##                spat_comp[&#39;params&#39;][r] = (</span>
<span class="c">##                    A[spat_ind].T</span>
<span class="c">##                    )</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.estim_param_a_post_model"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.estim_param_a_post_model">[docs]</a>    <span class="k">def</span> <span class="nf">estim_param_a_post_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;estim_param_a_post_model</span>
<span class="sd">        </span>
<span class="sd">        Estimation of model parameters, using the sparsity constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">logSigma0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">spec</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">logSigmaInf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span>
        
        <span class="n">logliks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="s">&#39;no_ann&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;To add noise to the signal, provide the &quot;</span><span class="o">+</span>
                          <span class="s">&quot;sim_ann_opt from any of &#39;ann&#39;, &quot;</span><span class="o">+</span>
                          <span class="s">&quot;&#39;no_ann&#39; or &#39;ann_ns_inj&#39; &quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Iteration&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span>
            <span class="c"># adding the noise psd if required:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="s">&#39;ann_ns_inj&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                
            <span class="c"># running the GEM iteration:</span>
            <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEM_iteration</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    log-likelihood:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        improvement:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    
            <span class="c"># sparsity</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logSigma0</span> <span class="o">+</span>
                           <span class="p">(</span><span class="n">logSigmaInf</span> <span class="o">-</span> 
                            <span class="n">logSigma0</span><span class="p">)</span> <span class="o">/</span> 
                           <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reweigh_sparsity_constraint</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">logliks</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.reweigh_sparsity_constraint"><a class="viewcode-back" href="../../audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.reweigh_sparsity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">reweigh_sparsity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;reweigh_sparsity_constraint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;reweigh_sparsity_constraint:&quot;</span>
            <span class="k">print</span> <span class="s">&quot;    sigma&quot;</span><span class="p">,</span> <span class="n">sigma</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
            <span class="n">spec_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="ow">and</span> \
                   <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">TW</span> <span class="o">=</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">TW</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c"># barycenter from energy of factor 0 TW component</span>
                <span class="n">muTW</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> 
                           <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                           <span class="n">TW</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span> <span class="o">/</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">TW</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">eps</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="c"># smoothing the sequence:</span>
                <span class="n">muTW</span>  <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">medianFilter</span><span class="p">(</span><span class="n">muTW</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;sparsity&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        muTW NaNs in comp </span><span class="si">%d</span><span class="s">:&quot;</span> <span class="o">%</span><span class="n">j</span><span class="p">,</span>
                    <span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">muTW</span><span class="p">))</span>
                
                <span class="n">twmask</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span>
                           <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">-</span> <span class="n">muTW</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                           <span class="n">sigma</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">twmask</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">twmask</span><span class="p">[:,</span><span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">TW</span> <span class="o">*=</span> <span class="n">twmask</span>
</div></div>
<span class="k">class</span> <span class="nc">multichanLead</span><span class="p">(</span><span class="n">multiChanSourceF0Filter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;multichanLead</span>
<span class="sd">        </span>
<span class="sd">        subclasses multiChanSourceF0Filter</span>
<span class="sd">        </span>
<span class="sd">        Provides additional methods to estimate the lead/accompaniment parameters</span>
<span class="sd">        meant to be used as initial parameters for one of the sources.</span>
<span class="sd">        </span>
<span class="sd">        Tentative plan for estimation:</span>
<span class="sd">        ## estimate the Lead/Accompaniment using SIMM</span>
<span class="sd">        ## estimate the spatial parameters for each of the separated signals</span>
<span class="sd">        ## plug the SIMM params and the spatial params into pyFASST, and</span>
<span class="sd">        ## re-estimate</span>
<span class="sd">        ## write the estimated signals and enjoy success!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">multichanLead</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># removing some data from the object, recomputing when needed:</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span>
        <span class="c">##del self.spec_comps</span>
        
    <span class="k">def</span> <span class="nf">runDecomp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instrus</span><span class="o">=</span><span class="p">[],</span>
                  <span class="n">instru2modelfile</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">dir_results</span><span class="o">=</span><span class="s">&#39;tmp/&#39;</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
                  <span class="n">niter_nmf</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">niter_simm</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Running the scheme that should make me famous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># running some checks that the input is alright:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instrus</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="s">&#39;SourceFilter&#39;</span> <span class="ow">or</span>
                   <span class="n">i</span> <span class="ow">in</span> <span class="n">instru2modelfile</span> <span class="ow">or</span>
                   <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;Free_&quot;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Instrument </span><span class="si">%s</span><span class="s"> not known.&#39;</span> <span class="o">%</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c"># just running everything in __init__:</span>
        <span class="c"># estimating the separated </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimSUIMM</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">,</span>
                        <span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                        <span class="n">simmIterNum</span><span class="o">=</span><span class="n">niter_simm</span><span class="p">)</span>
        
        <span class="c">##############</span>
        <span class="c"># entering vacuum of nightmare of research trial and errors...</span>
        <span class="c"># thus expect many undesirable commented lines...</span>
        
        <span class="c"># putting everything in the right containers:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_transf_Cx</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_structures</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeItConvolutive</span><span class="p">()</span>
        
        <span class="c"># running DEMIX:</span>
        <span class="c">## 20130604 no need anymore, only for ALead:</span>
        <span class="n">ALead</span><span class="p">,</span> <span class="n">AAccp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnSepSIMM</span><span class="p">(</span><span class="n">unvoiced</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c">#   spatial components:</span>
        <span class="c">#    accompaniment parameters:</span>
        <span class="c">## THE FOLLOWING SEEMS TO LEAD TO ISSUES and results not so good...</span>
        <span class="c">## 20130604 do this after initialize with NMF...</span>
        <span class="c">## for j in range(1, self.nbComps-1):</span>
        <span class="c">##     for r in range(self.rank):</span>
        <span class="c">##       ## the following assumes the instruments are sorted in the</span>
        <span class="c">##       ## right order, but we still need to think about that !</span>
        <span class="c">##       # self.spat_comps[j][&#39;params&#39;][r][:,:] = AAccp[j-1].T</span>
        <span class="c">##       # so for now, we just go for the sum of all the mixing params</span>
        <span class="c">##       self.spat_comps[j][&#39;params&#39;][r][:,:] = AAccp.sum(axis=0).T</span>
        <span class="c">## Trying randomized init:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializeConvParams</span><span class="p">(</span><span class="n">initMethod</span><span class="o">=</span><span class="s">&#39;rand&#39;</span><span class="p">)</span>
        <span class="c">#    no modif for noise component...</span>
        <span class="c">#    lead instrument spatial mat:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">ALead</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c">#   spectral components:</span>
        
        <span class="c">## Using the instrument models to initialize the matrices:</span>
        <span class="c"># For convenience, we do this in a separate method:</span>
        <span class="n">instrumentNames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initSpecCompsWithLabelAndFiles</span><span class="p">(</span>
            <span class="n">instrus</span><span class="o">=</span><span class="n">instrus</span><span class="p">,</span>
            <span class="n">instru2modelfile</span><span class="o">=</span><span class="n">instru2modelfile</span><span class="p">,</span>
            <span class="n">freqBasisAdaptive</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">)</span>
        <span class="c">## instrumentNames = {}</span>
        <span class="c">## for n, i in enumerate(instrus):</span>
        <span class="c">##     instrumentNames[n] = i</span>
        <span class="c">##     if i == &#39;SourceFilter&#39;:</span>
        <span class="c">##         print &quot;    Source&quot;, n, &quot;left as general Source-Filter model.&quot;</span>
        <span class="c">##     elif &#39;Free&#39; in i: # assumes Free_nbNMFComps</span>
        <span class="c">##         nbNMFComps = int(i.split(&#39;_&#39;)[-1])</span>
        <span class="c">##         print &quot;    Source&quot;, n, &quot;set as free NMF source.&quot;</span>
        <span class="c">##         # initialize single factor spectral component</span>
        <span class="c">##         self.spec_comps[n] = {}</span>
        <span class="c">##         self.spec_comps[n][&#39;spat_comp_ind&#39;] = n</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;] = {}</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0] = {}</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FB&#39;] = (</span>
        <span class="c">##             0.75 * np.abs(np.random.randn(self.nbFreqsSigRepr,</span>
        <span class="c">##                                           nbNMFComps)) +</span>
        <span class="c">##             0.25)</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FW&#39;] = (</span>
        <span class="c">##             np.eye(nbNMFComps))</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TW&#39;] = (</span>
        <span class="c">##             0.75 * np.abs(np.random.randn(nbNMFComps,</span>
        <span class="c">##                                           self.nbFramesSigRepr)) +</span>
        <span class="c">##             0.25)</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TB&#39;] = []</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FB_frdm_prior&#39;] = &#39;free&#39;</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FW_frdm_prior&#39;] = &#39;fixed&#39;</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TW_frdm_prior&#39;] = &#39;free&#39;</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TB_frdm_prior&#39;] = []</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TW_constr&#39;] = &#39;NMF&#39;</span>
        <span class="c">##         # sparsity stuff</span>
        <span class="c">##         sparsity = self.sparsity</span>
        <span class="c">##         if sparsity is None or len(sparsity) not in (1, self.nbComps):</span>
        <span class="c">##             self.spec_comps[n][&#39;sparsity&#39;] = False</span>
        <span class="c">##         elif len(sparsity) == self.nbComps:</span>
        <span class="c">##             self.spec_comps[n][&#39;sparsity&#39;] = sparsity[n]</span>
        <span class="c">##         else:</span>
        <span class="c">##             self.spec_comps[n][&#39;sparsity&#39;] = sparsity[0]</span>
        <span class="c">##     else: #if i != &#39;SourceFilter&#39;:</span>
        <span class="c">##         print &quot;    Source&quot;, n, &quot;is&quot;, i</span>
        <span class="c">##         modelfile = instru2modelfile[i]</span>
        <span class="c">##         struc = np.load(modelfile)</span>
        <span class="c">##         gsmm = struc[&#39;gsmm&#39;].tolist()</span>
        <span class="c">##         # Keeping only spectra that are not flat:</span>
        <span class="c">##         decisionSpectra = np.any(np.diff(gsmm.sigw, axis=1)!=0, axis=1)</span>
        <span class="c">##         # keeping only the spectra with enough weight:</span>
        <span class="c">##         #     hard decision, remove all spectra with w == min(w)</span>
        <span class="c">##         # decisionOnWeight = np.where(gsmm.w!=gsmm.w.min())[0]</span>
        <span class="c">##         #     harder decision: remove all with w under a threshold:</span>
        <span class="c">##         decisionOnWeight = (gsmm.w &gt; gsmm.w.max()*1e-3)</span>
        <span class="c">##         </span>
        <span class="c">##         keepIndex = np.where(decisionSpectra+decisionOnWeight)[0]</span>
        <span class="c">##         </span>
        <span class="c">##         FB = np.ascontiguousarray(gsmm.sigw[keepIndex].T)</span>
        <span class="c">##         #self.setSpecCompFB(compNb=n, FB=FB, FB_frdm_prior=&#39;fixed&#39;)</span>
        <span class="c">##         self.setSpecCompFB(compNb=n, FB=FB, FB_frdm_prior=&#39;free&#39;)</span>
        <span class="c">##         struc.close()</span>
        
        <span class="n">suffix</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">instrumentNames</span><span class="p">)</span>
        <span class="c"># suffix[len(suffix)] = &#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;suffix&#39;</span><span class="p">,</span> <span class="n">suffix</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
        <span class="c"># initialize parameters with NMF:</span>
        <span class="c"># putting the HF0 from the SIMM model back in:</span>
        <span class="c">#    lead instrument</span>
        <span class="c">##self.spec_comps[0][&#39;factor&#39;][0][&#39;TW&#39;][:-1] = (</span>
        <span class="c">##    self.simmModel.SIMMParams[&#39;HF00&#39;])</span>
        <span class="n">startincqt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">time_stamps</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stopincqt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">startincqt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
            <span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_all_spec_comps_with_NMF</span><span class="p">(</span><span class="n">updateFreqBasis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                <span class="n">niter</span><span class="o">=</span><span class="n">niter_nmf</span><span class="p">)</span>
        <span class="c"># putting the HF0 from the SIMM model back in:</span>
        <span class="c">#    lead instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
            <span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">])</span>
        <span class="c">##self.spec_comps[0][&#39;factor&#39;][0][&#39;TW&#39;][:-1] = (</span>
        <span class="c">##    self.simmModel.SIMMParams[&#39;HF00&#39;])</span>
        <span class="c">#        the following are too variable to be kept for now:</span>
        <span class="c">#self.spec_comps[0][&#39;factor&#39;][1][&#39;TW&#39;][:-1] = (</span>
        <span class="c">#    self.simmModel.SIMMParams[&#39;HPHI&#39;])</span>
        <span class="c">#self.spec_comps[0][&#39;factor&#39;][1][&#39;FW&#39;][:-1] = (</span>
        <span class="c">#    self.simmModel.SIMMParams[&#39;HGAMMA&#39;])</span>
        <span class="c">#self.spec_comps[0][&#39;factor&#39;][1][&#39;FB&#39;][:-1] = (</span>
        <span class="c">#    self.simmModel.SIMMParams[&#39;WGAMMA&#39;])</span>
        
        <span class="c">#    accompaniment: nothing for now.</span>
        <span class="c">#    accompaniment: avoid or reduce effect of stuff in source 0, maybe:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instrumentNames</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;SourceFilter&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][</span>
                    <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#    noise: nothing for now.</span>
        
        <span class="c">## 20130605T0104</span>
        <span class="c">##    Should we iterate a sequence of (estim_param_a_post_model, demix)</span>
        <span class="c">##    here? </span>
        
        <span class="c"># separate the files with these parameters:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spat_comps</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                                 <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">suffix</span>
        
        <span class="c"># replace this with method:</span>
        <span class="c"># run DEMIX on the separated files:</span>
        <span class="c">##estFiles = self.files[&#39;spat_comp&#39;]</span>
        <span class="c">##nbSources = len(self.spat_comps)</span>
        <span class="c">##if self.verbose&gt;1:</span>
        <span class="c">##    print nbSources, &quot;sources:&quot;, estFiles</span>
        <span class="c">##for nest, estfilename in enumerate(estFiles):</span>
        <span class="c">##    if self.verbose&gt;1:</span>
        <span class="c">##        print estfilename</span>
        <span class="c">##    A = self.demixOnGivenFile(estfilename, nsources=1)</span>
        <span class="c">##    for r in range(self.rank[nest]):</span>
        <span class="c">##        self.spat_comps[nest][&#39;params&#39;][r][:,:] = (</span>
        <span class="c">##            A[0].T + 1e-3 * np.random.randn(*A[0].T.shape))</span>
        <span class="c">##</span>
        <span class="c">##self.renormalize_parameters()</span>
        
        <span class="n">estFiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initConvDemixOnSepSrc</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spatial_filter_comp</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                                          <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
        
        <span class="c"># Re-estimating all the parameters:</span>
        <span class="n">logliks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estim_param_a_post_model</span><span class="p">()</span>
        
        <span class="c"># Separate and Write them...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Writing files to&quot;</span><span class="p">,</span> <span class="n">dir_results</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spat_comps</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                                 <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">logliks</span>
    
    <span class="k">def</span> <span class="nf">estimSIMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">dir_results</span><span class="o">=</span><span class="s">&#39;tmp/&#39;</span><span class="p">,</span> <span class="n">simmIterNum</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method runs the SIMM estimation on the provided audio file.</span>
<span class="sd">        </span>
<span class="sd">        The lead source is assumed to be self.spec_comps[0]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">##numCompAccomp = (</span>
        <span class="c">##        np.sum([spec_comp[&#39;factor&#39;][0][&#39;FB&#39;].shape[1]</span>
        <span class="c">##                for ncomp, spec_comp in self.spec_comps.items()])-</span>
        <span class="c">##        self.spec_comps[0][&#39;factor&#39;][0][&#39;FB&#39;].shape[1]</span>
        <span class="c">##        )</span>
        <span class="n">numCompAccomp</span> <span class="o">=</span> <span class="mi">40</span> <span class="c"># TODO: check if this improves solo/acc separation</span>
        <span class="k">if</span> <span class="n">simmIterNum</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">simmIterNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span> <span class="o">=</span> <span class="n">SLS</span><span class="o">.</span><span class="n">SeparateLeadProcess</span><span class="p">(</span>
            <span class="n">inputAudioFilename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;stepnoteF0&#39;</span><span class="p">],</span>
            <span class="n">chirpPerF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
            <span class="n">nbIter</span><span class="o">=</span><span class="n">simmIterNum</span><span class="p">,</span>
            <span class="n">windowSize</span><span class="o">=</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span><span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)),</span> <span class="c"># in seconds</span>
            <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
            <span class="n">NFT</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
            <span class="n">numCompAccomp</span><span class="o">=</span><span class="n">numCompAccomp</span><span class="p">,</span>
            <span class="n">K_numFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">P_numAtomFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span><span class="p">,</span>
            <span class="c">#imageCanvas=canvas,</span>
            <span class="n">minF0search</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;minF0search&#39;</span><span class="p">],</span>
            <span class="n">maxF0search</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;maxF0search&#39;</span><span class="p">],</span>
            <span class="n">minF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">],</span>
            <span class="n">maxF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">],</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">tfrepresentation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">],</span>
            <span class="n">cqtfmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmax&#39;</span><span class="p">],</span><span class="c">#4000,</span>
            <span class="n">cqtfmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmin&#39;</span><span class="p">],</span><span class="c">#50,</span>
            <span class="n">cqtbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfbpo&#39;</span><span class="p">],</span><span class="c">#48,</span>
            <span class="n">cqtWinFunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfWinFunc&#39;</span><span class="p">],</span>
            <span class="c">#slf.minqt.sqrt_blackmanharris,</span>
            <span class="n">cqtAtomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">],</span><span class="c">#0.25,</span>
            <span class="n">outputDirSuffix</span><span class="o">=</span><span class="s">&#39;tmp/&#39;</span><span class="p">,</span> <span class="c"># dir_results,</span>
            <span class="c"># this is not working, have to find a way</span>
            <span class="n">initHF00</span><span class="o">=</span><span class="s">&#39;random&#39;</span><span class="p">,</span>
            <span class="n">freeMemory</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">autoMelSepAndWrite</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">estimSUIMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separates the audio signal into lead+accompaniment,</span>
<span class="sd">        including more noisy components for the lead than `self.estimSIMM`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;simmModel&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimSIMM</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">estimStereoSUIMMParamsWriteSeps</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        
    
    <span class="k">def</span> <span class="nf">demixOnSepSIMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unvoiced</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;run DEMIX on the separated signals resulting from SIMM model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;simmModel&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimSIMM</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">unvoiced</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimSUIMM</span><span class="p">()</span>
                
        <span class="k">if</span> <span class="n">unvoiced</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;_VUIMM&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="c"># DEMIX on lead instrument</span>
        <span class="n">leadfilename</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span><span class="p">)</span>
        <span class="n">ALead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnGivenFile</span><span class="p">(</span>
            <span class="n">leadfilename</span><span class="p">,</span>
            <span class="n">nsources</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c"># DEMIX on accompaniment</span>
        <span class="n">accpfilename</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span><span class="p">)</span>
        <span class="n">AAccp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnGivenFile</span><span class="p">(</span>
            <span class="n">accpfilename</span><span class="p">,</span>
            <span class="n">nsources</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ALead</span><span class="p">,</span> <span class="n">AAccp</span>
    
    <span class="k">def</span> <span class="nf">demixOnGivenFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">nsources</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;running the DEMIX algorithm from :demix.DEMIX:</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">maxclusters</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="mi">15</span>
        
        <span class="c"># default for demix to work best: #FIXME!!!</span>
        <span class="c">#wlen = 2048</span>
        <span class="c">#hopsize = 1024</span>
        
        <span class="n">demixInst</span> <span class="o">=</span> <span class="n">demix</span><span class="o">.</span><span class="n">DEMIX</span><span class="p">(</span>
            <span class="n">audio</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">nsources</span><span class="o">=</span><span class="n">nsources</span><span class="p">,</span> <span class="c"># spatial comps for demix</span>
            <span class="c">#wlen=wlen,</span>
            <span class="c">#hopsize=hopsize,</span>
            <span class="c">#neighbors=neighbours,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">maxclusters</span><span class="o">=</span><span class="n">maxclusters</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span><span class="p">)</span>
            
        <span class="c">#demixInst.comp_pcafeatures()</span>
        <span class="c">#demixInst.comp_parameters()</span>
        <span class="c">#demixInst.init_subpts_set()</span>
        <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_clusters</span><span class="p">()</span>
        <span class="n">demixInst</span><span class="o">.</span><span class="n">refine_clusters</span><span class="p">()</span>
        
        <span class="c"># mixing parameters from DEMIX estimation:</span>
        <span class="c">#     results in an nsrc x nfreqs x nc array</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">demixInst</span><span class="o">.</span><span class="n">steeringVectorsFromCentroids</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">demixInst</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnMsg</span> <span class="o">=</span> <span class="s">&quot;There are no clusters in demix, returning dummy matrix.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warnMsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="n">warnMsg</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">nsources</span><span class="p">,</span>
                                                   <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">A</span>
    
    <span class="k">def</span> <span class="nf">initConvDemixOnSepSrc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize the convolutive parameters with DEMIX, running on each of</span>
<span class="sd">        the separated sources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;files&quot;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The sources were not separated, compute them first&quot;</span><span class="o">+</span>
                          <span class="s">&quot; with separate_spat_comps.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">estFiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spat_comp&#39;</span><span class="p">]</span>
        <span class="n">nbSources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">nbSources</span><span class="p">,</span> <span class="s">&quot;sources:&quot;</span><span class="p">,</span> <span class="n">estFiles</span>
        <span class="k">for</span> <span class="n">nest</span><span class="p">,</span> <span class="n">estfilename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">estFiles</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="n">estfilename</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnGivenFile</span><span class="p">(</span><span class="n">estfilename</span><span class="p">,</span> <span class="n">nsources</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nest</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">nest</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">estFiles</span>
    
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyFASST 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Jean-Louis Durrieu.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>